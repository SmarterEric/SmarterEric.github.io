<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <!-- PACE Progress Bar START -->
  
    <script src="/js/pace.min.js"></script>
    <link rel="stylesheet" href="https://github.com/HubSpot/pace/raw/master/themes/orange/pace-theme-flash.css">
  
  

  <!-- PACE Progress Bar START -->

  
  <title>go语言细节及重点汇总 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="Golang细节汇总mac goland 安装mac系统安装并配置 安装 双击pkg包，顺着指引，即可安装成功。  在命令行输入 go version，获取到go的版本号，则代表安装成功。 配置环境变量 1、打开终端输入cd ~进入用户主目录;  2、输入ls -all命令查看是否存在.bash_profile;  3、存在既使用vim .bash_profile 打开文件;  4、输入 i 进入">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言细节及重点汇总">
<meta property="og:url" content="http://yoursite.com/2018/05/02/Golang细节汇总/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Golang细节汇总mac goland 安装mac系统安装并配置 安装 双击pkg包，顺着指引，即可安装成功。  在命令行输入 go version，获取到go的版本号，则代表安装成功。 配置环境变量 1、打开终端输入cd ~进入用户主目录;  2、输入ls -all命令查看是否存在.bash_profile;  3、存在既使用vim .bash_profile 打开文件;  4、输入 i 进入">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/9c0a3e77aee595f07194cb7cce079811/xmlnote/0FC740ACE2114E5DA5678F848911BCD6/32BA34A8FF704B5E95B9C9A0C93CB942/418">
<meta property="og:updated_time" content="2018-05-02T14:08:37.918Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go语言细节及重点汇总">
<meta name="twitter:description" content="Golang细节汇总mac goland 安装mac系统安装并配置 安装 双击pkg包，顺着指引，即可安装成功。  在命令行输入 go version，获取到go的版本号，则代表安装成功。 配置环境变量 1、打开终端输入cd ~进入用户主目录;  2、输入ls -all命令查看是否存在.bash_profile;  3、存在既使用vim .bash_profile 打开文件;  4、输入 i 进入">
<meta name="twitter:image" content="https://note.youdao.com/yws/public/resource/9c0a3e77aee595f07194cb7cce079811/xmlnote/0FC740ACE2114E5DA5678F848911BCD6/32BA34A8FF704B5E95B9C9A0C93CB942/418">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/my.css">
  <!-- Google Adsense -->
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
      (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-0123456789ABCDEF",
          enable_page_level_ads: true
      });
  </script>
</head>

<script>
var themeMenus = {};

  themeMenus["/"] = "首页"; 

  themeMenus["/archives"] = "归档"; 

  themeMenus["/categories"] = "分类"; 

  themeMenus["/tags"] = "标签"; 

  themeMenus["/about"] = "关于"; 

</script>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Hexo" rel="home"> Hexo </a>
            
          </h1>

          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>


  <div id="originBgDiv" style="background: #fff; width: 100%;">

      <div style="max-height:600px; overflow: hidden;  display: flex; display: -webkit-flex; align-items: center;">
        <img id="originBg" width="100%" alt="" src="">
      </div>

  </div>

  <script>
  function setAboutIMG(){
      var imgUrls = "css/images/pose.jpg,https://source.unsplash.com/collection/954550/1920x1080".split(",");
      var random = Math.floor((Math.random() * imgUrls.length ));
      if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
        document.getElementById("originBg").src=imgUrls[random];
      } else {
        document.getElementById("originBg").src='/' + imgUrls[random];
      }
  }
  bgDiv=document.getElementById("originBgDiv");
  if(location.pathname.match('about')){
    setAboutIMG();
    bgDiv.style.display='block';
  }else{
    bgDiv.style.display='none';
  }
  </script>



  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Golang细节汇总" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      go语言细节及重点汇总
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/02/Golang细节汇总/" class="article-date">
	  <time datetime="2018-05-02T13:53:12.506Z" itemprop="datePublished">五月 2, 2018</time>
	</a>

      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Golang细节汇总"><a href="#Golang细节汇总" class="headerlink" title="Golang细节汇总"></a>Golang细节汇总</h1><h2 id="mac-goland-安装"><a href="#mac-goland-安装" class="headerlink" title="mac goland 安装"></a>mac goland 安装</h2><p>mac系统安装并配置</p>
<p>安装</p>
<p>双击pkg包，顺着指引，即可安装成功。 </p>
<p>在命令行输入 go version，获取到go的版本号，则代表安装成功。</p>
<p>配置环境变量</p>
<p>1、打开终端输入cd ~进入用户主目录; </p>
<p>2、输入ls -all命令查看是否存在.bash_profile; </p>
<p>3、存在既使用vim .bash_profile 打开文件; </p>
<p>4、输入 i 进入vim编辑模式； </p>
<p>5、输入下面代码， </p>
<p>其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。</p>
<p>export GOPATH=/Users/ruby/go</p>
<p>export GOBIN=$GOPATH/bin</p>
<p>export PATH=$PATH:$GOBIN</p>
<p>6、点击ESC，并输入 :wq 保存并退出编辑。可输入vim .bash_profile 查看是否保存成功。</p>
<p>7、输入source ~/.bash_profile 完成对golang环境变量的配置，配置成功没有提示。 </p>
<p>8、输入go env 查看配置结果</p>
<h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><p>正数的原码，反码，补码都是二进制的本身（第一位表示符号位）</p>
<p>负数的第一位为1，表示负数</p>
<p>负数的反码是在其原码的基础上，符号位不变，其余各位按位取反</p>
<p>负数的补码是反码+1</p>
<p>计算机存储数值都是二进制，而且是以补码的形式存储。为了解决负数问题</p>
<h2 id="switch-fallthrough用法"><a href="#switch-fallthrough用法" class="headerlink" title="switch fallthrough用法"></a>switch fallthrough用法</h2><p><1> 如需贯通后续的case，就添加fallthrough</1></p>
<p>如：</p>
<pre><code>switch x := 5; x {
default:
    fmt.Println(x)
case 5:
    x += 10
    fmt.Println(x)
    fallthrough
case 6:
    x += 20
    fmt.Println(x)

}
</code></pre><p>输出</p>
<p>15<br>35</p>
<p><2>case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。</2></p>
<pre><code>func main(){
num := 75
switch { // expression is omitted
case num &gt;= 0 &amp;&amp; num &lt;= 50:
    fmt.Println(&quot;num is greater than 0 and less than 50&quot;)
case num &gt;= 51 &amp;&amp; num &lt;= 100:
    fmt.Println(&quot;num is greater than 51 and less than 100&quot;)
case num &gt;= 101:
    fmt.Println(&quot;num is greater than 100&quot;)
      }
}
</code></pre><p><3>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</3></p>
<p>语法以及举证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">" x 的类型 :%T"</span>,i)                </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">"x 是 int 型"</span>)                       </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 float64 型"</span>)           </span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">float64</span>:</span></span><br><span class="line">         fmt.Printf("x 是 func(int) 型")                      </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 bool 或 string 型"</span> )       </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"未知型"</span>)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 </p>
</li>
<li><p>否则：</p>
<p>如果有default子句，则执行该语句。</p>
<p>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>
</li>
</ul>
<h2 id="slice-array切片和数组的创建"><a href="#slice-array切片和数组的创建" class="headerlink" title="slice,array切片和数组的创建"></a>slice,array切片和数组的创建</h2><p>1.数组 ：值传递</p>
<p>​    概念：存储一组相同的数据类型的数据结构。</p>
<p>​    特点：数据结构：内存上是连续空间。</p>
<p>​    存储数据特点：有序，可以重复。</p>
<p>​                数据类型一致。</p>
<p>​                定长：数组一旦创建长度不能更改，但是可以更改存储的数据。</p>
<p>​    语法：</p>
<p>   A：数组的创建</p>
<p>   var variable_name [SIZE] variable_type</p>
<p>​     var a [4] int</p>
<p>​     var b = [4]int{}</p>
<p>​      var c = [4] int {1,2,3,4}</p>
<p>​     var d = [4]int{1,2}//后边补零</p>
<p>​      e := [4]int{index:value}</p>
<p>​      f:=[…] int{}</p>
<p>   B：数组的访问</p>
<p>​      主要通过下标：index，取值范围是：从0开始，到长度减1。</p>
<p>​      index（下标）：,数据在数组中的位置。从0开始，到长度减1。否则越界异常。</p>
<p>​      赋值：数组名[index] = value（数据）</p>
<p>​      取值：数组名[index]</p>
<p>遍历数组：依次获取数组中的数据</p>
<p>​            range 数组名：index，value</p>
<p>​    数组的类型：值类型：传递该数据的时候，传递数据的副本(备份，复制)</p>
<p>​            arr1:=[5] int {1,1,1,1,1}</p>
<p>​            arr2 = arr1//将arr1的数据拷贝一份，值赋值给arr2。</p>
<p>​                        //如果在把arr1的值赋值给arr1之后，更改了arr1的内容，对于arr2没</p>
<p>​                            有影响。因为是值类型，传递的是备份数据。        </p>
<p>​    循环操作数组：</p>
<p>​            for i:=0;i&lt;len(arr);i++{</p>
<p>​                arr[i] </p>
<p>​            }</p>
<p>​            range–&gt;数组：将数组的下标和对应的数值</p>
<p>​            for index,value := range arr{</p>
<p>​                index：下标</p>
<p>​                value：数据</p>
<p>​            }</p>
<p>​    数据类型：数组的类型：[size]type，</p>
<p>​    数组的排序：数组中的数据，按照升序或降序排列。</p>
<p>​    冒泡排序：思路：每次比较相邻的两个数，如果前一个数大于后一个数，交换。排n轮：    </p>
<p>​                长度-1    </p>
<p>a := [5] int {30,31,18,17,15}</p>
<p>for i:=1;i&lt;len(a);i++{</p>
<p> for j:=0;j&lt;len(a)-i;j++{</p>
<p>​     if a[j]&gt;a[j+1]{</p>
<p>​        a[j] ,a[j+1]=a[j+1],a[j]</p>
<p>​      }</p>
<p>   }</p>
<p>   fmt.Println(a)</p>
<p>​    多维数组：二维数组：一维的一维</p>
<p>​            一维数组，直接存储数据本身</p>
<p>​            二维数组，存储的是一维数组</p>
<p>语法：       c := [3][4] int{</p>
<p>​                     {1,2,3,4},</p>
<p>​                     {5,6,7,8},</p>
<p>​                  {9,10,11,12}}</p>
<p>len(b)–&gt;二维数组的长度：存储了几个一维数组</p>
<p>len(b[0])–&gt;第一个一维数组的长度</p>
<p>b[0][0]–&gt;第一个一维数组中，第一个数据</p>
<p>len(),cap()，数组的长度和容量一致的。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9c0a3e77aee595f07194cb7cce079811/xmlnote/0FC740ACE2114E5DA5678F848911BCD6/32BA34A8FF704B5E95B9C9A0C93CB942/418" alt="img"></p>
<p>​                </p>
<p>​    2.切片：slice（引用类型）</p>
<p>​        理解为变长的数组</p>
<p>​        A：切片创建</p>
<p>​            1.创建切片1.直接创建</p>
<p>​                 s1 := [] int{1,2,3,4,5,6,7,8}</p>
<p>​            2.使用make([]T, len,cap) cap如果不给数值，那么和len一致，                                         </p>
<p>​                 s2:=make([]T,len,cap)</p>
<p>​                 s3 := make([]int, 3, 8)</p>
<p>​            3.在数组的基础上创建切片</p>
<p>​                b := [10]int{1,2,3,4,5,6,7,8,9,10}</p>
<p>​                s4 := b[2:6] // 数组名[start:end），start，end指的是下标。不包含end</p>
<p>​                s5 := b[:6] // [0:6]，从头开始，切割刀下标6(不包含6)</p>
<p>​                s6 :=b[6:] // [start:],从start开始，切割刀最后</p>
<p>​        B：切片的类型：</p>
<p>​                []数据类型    </p>
<p>​                切片属于引用类型：</p>
<p>​                s1:=[] int{1,2,3,4}</p>
<p>​                s2:=s1</p>
<p>​            append(slice, ele1,ele2,ele3)//向切片后面直接加数值</p>
<p>​            append(slice1,slice2…)//向切片后面加切片，注意加 …</p>
<p>​        </p>
<h2 id="slice-copy和append方法"><a href="#slice-copy和append方法" class="headerlink" title="slice copy和append方法"></a>slice copy和append方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">len(),存储的实际的数量</span><br><span class="line">cap(),存储的最大的数量，自动扩容：规则：2倍</span><br><span class="line">append(slice, ele1,ele2,ele3)，增加同类型元素</span><br><span class="line">append(slice1,slice2...)，增加切片里元素</span><br><span class="line">cap:0--&gt;1--&gt;2--&gt;4--&gt;8--&gt;16--&gt;32，倍数增加容量</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝 numbers 的内容到 numbers1,如果numbers1的长度小于numbers，那么numbers1内的数值将被全部覆盖 </span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">12</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的</p>
</blockquote>
<p>Append里有个坑，详见例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   a := make([]int, 5, 10)</span><br><span class="line">   b := append(a, 1)//新开辟内存b，b内的值是指针传递，由a传递，a变化，b也会跟着相应变化</span><br><span class="line">   _ = append(a, 2)</span><br><span class="line">   a[0]=9</span><br><span class="line">   a=append(a,3,4,5)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line">   fmt.Printf(&quot;%p&quot;,&amp;b)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>[9 0 0 0 0 3 4 5]<br>[9 0 0 0 0 3]<br>0xc0420023e0<br>0xc042002400</p>
<h2 id="Map-字典"><a href="#Map-字典" class="headerlink" title="Map 字典"></a>Map 字典</h2><p>Map集合是引用类型：传递时候，传递的是地址。</p>
<pre><code>映射。存储一组无需的键值对的容器。
存储的特点：a.键与值是一一对应的。----&gt;映射
            b.键是唯一的
</code></pre><p>语法：<br>   A：创建：如果一个map仅有声明，就是nil map，不能直接存储数据<br>   var map名 [key类型]value类型<br>   map名:=map[key类型]value类型{}<br>   map名:=make(map[key类型]value类型)<br>   B：向map中添加数据<br>              map[key] = value</p>
<p>   C：获取map的数据：根据key获取value，如果key 不存在<br>         /<em> 使用 key 输出 map 值 </em>/<br>         map1:=make(map[int]string)<br>       for key := range map1 {<br>          fmt.Println(key,map1[key])<br>       }</p>
<pre><code>   /* 查看元素在集合中是否存在 */
   value, ok := map1[key]
   /* 如果 ok 是 true, 则存在，否则不存在 */
   if(ok){
      fmt.Println(value)  
   }else {
      fmt.Println(&quot;value is not present&quot;) 
   }
D：删除键值对
  delete(map,key)
  根据key删除键值对，如果key不存在，删除失败。
</code></pre><p>   E：修改：<br>      根据key修改<br>map的遍历：<br>创建slice，利用append函数，将map中的key值遍历再加入到slice中，排序<br>//1.定义一个slice<br>s1 := make([]int,0,len(map2))<br>//2.遍历map获取key–&gt;s1中<br>for key := range map2{<br>   s1 = append(s1, key)<br>}<br>//3.给s1进行排序<br>sort.Ints(s1)//使用sort包下的方法直接排序，不用自己写冒泡了。<br>//4. 遍历s1，map<br>for _,k:=range s1{ // 先下标，再数值<br>   fmt.Println(k, map2[k])<br>}</p>
<h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><p> 字符串：多个字节的集合。理解为一个字符序列。</p>
<p>​            //长度：字符串中的字节的数量。</p>
<p>​            //序列：有序–&gt;下标，也叫索引，每个字符的位置。从0开始，到长度减1。</p>
<p>​            遍历：可以根据字符的下标，进行访问遍历</p>
<p>​                 for i:=0;i&lt;len(s2);i++{</p>
<pre><code>//fmt.Println(s2[i])

fmt.Printf(&quot;%c\n&quot;,s2[i])
</code></pre><p>​                }</p>
<p>​            字符串—&gt;[]byte</p>
<p>​            []byte(s1)</p>
<p>​            string(arr1)</p>
<p>​        strings函数包使用方法：</p>
<p>​                s1:=”HelloWorld”</p>
<p>​                s2:=”20180403课堂笔记.txt”</p>
<p>​    1.strings.Contains(s,””)：返回值为bool    </p>
<p>​            是否包含指定内容，</p>
<p>​                        fmt.Println(strings.Contains(s1,”O”))</p>
<p>​                        //判断s1中是否包含“0”</p>
<p>​    2.strings.ContainsAny(s,””)：返回值为bool</p>
<p>​            是否包含指定内容中的任意一个，</p>
<p>​                        fmt.Println(strings.ContainsAny(s1,”abcd”))</p>
<p>​                        //判断s1中是否包含”abcd”中的任意一个</p>
<p>​    3.strings.HasPrefix(s,””)：返回值为bool</p>
<p>​            判断s是否有前缀字符串，</p>
<p>​                        if strings.HasPrefix(s2,”201804”) {</p>
<pre><code>fmt.Println(&quot;这个是4月份的笔记。。&quot;)
</code></pre><p>​                        }</p>
<p>​                        //判断s2是不是以”201804”为开头的</p>
<p>​    4.strings.HasSuffix(s,””)：返回值为bool</p>
<p>​            判断s是否有后缀字符串</p>
<p>​                    if strings.HasSuffix(s2,”.txt”){</p>
<pre><code>fmt.Println(&quot;这个是一个文本文档。。&quot;)
</code></pre><p>​                    }</p>
<p>​                    //判断s2是不是以”.txt”为结束的</p>
<p>​    5.strings.Index(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中第一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.Index(s1,”llo”))</p>
<p>​                        //查找s1第一次出现”llo”的下标，不存在则返回-1.</p>
<p>​    6.strings.LastIndex(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中最后一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.LastIndex(s1,”l”))</p>
<p>​                        //查找s1最后一次出现”l”的下标，不存在则返回-1</p>
<p>​    7.strings.Count(s,””):返回值为int。</p>
<p>​            统计s字符串中出现子串” “的次数。</p>
<p>​                        fmt.Println(strings.Count(s1,”l”))</p>
<p>​                        //统计s1中出现”l”的次数</p>
<p>​    8.strings.Split(s1,””): 返回值为[]string</p>
<p>​                 用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所</p>
<p>​            有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会</p>
<p>​            进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值</p>
<p>​            一个字符串。</p>
<p>​            fmt.Println(strings.Split(“a man a plan a canal panama”, “a “))</p>
<p>​                        [ man  plan  canal panama]</p>
<p>​            //去掉”a man a plan a canal panama”中的”a “，即遇到 “a “以空格代替</p>
<p>​    9.strings.SplitN(s1,””,n): 返回值为[]string</p>
<p>​            指定次数的切割，不超过n次，即切割（n-1）次。如果全切n=-1</p>
<p>​            n == 0: 返回nil</p>
<p>​    10.strings.Join([]strings,””):返回值为string</p>
<p>​            将一系列字符串连接为一个字符串，之间用sep来分隔。</p>
<p>​            input：  s := []string{“foo”, “bar”, “baz”}                fmt.Println(strings.Join(s, “, “))</p>
<p>​            output：  foo, bar, baz</p>
<p>​    11.strings.ToLower(s):转小写，返回值为string</p>
<p>​       strings.ToUpper(s):转大写，返回值为string</p>
<p>​            fmt.Println(strings.ToLower(s1))//转小写</p>
<p>​            fmt.Println(strings.ToUpper(s1))//转大写</p>
<p>​    12.strings.Trim(s,cutset string): 返回值为string</p>
<p>​        返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</p>
<p>​    13.strings.Replace(s,old,new,n)n替换的次数，-1表示全部替换 返回值为string</p>
<p>​    strings.Repeat(s string, count int),=重复的次数  返回值为string</p>
<h2 id="func（）函数"><a href="#func（）函数" class="headerlink" title="func（）函数"></a>func（）函数</h2><p>函数是执行特定任务的代码块，打印函数名输出地址</p>
<p>参数有值传递和引用传递，引用传递将参数类型设为指针，传参&amp;参数</p>
<p>函数参数可以是可变参，如func myfunc(nums …int) </p>
<p>闭包：Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数体为getSequence() 的返回值，以后nextNumber函数自己独立 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回，地址不变 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">  fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="panic-和recover"><a href="#panic-和recover" class="headerlink" title="panic()和recover()"></a>panic()和recover()</h2><p>panic()执行导致程序出现恐慌，系统运行终止。需要借助defer函数使recover()接收错误，并恢复其他函数运行</p>
<p>panic()输出位置不固定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)//主函数终止，无法输出</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机输出1：</p>
<p>0<br>panic: 3<br>1</p>
<p>2<br>goroutine 1 [running]:<br>main.a()<br>    E:/kyxy/day01/ceshi.go:14 +0xed<br>main.main()<br>    E:/kyxy/day01/ceshi.go:8 +0x29</p>
<p>随机输出2：</p>
<p>panic: 3<br>0</p>
<p>1<br>goroutine 1 [running]:<br>2<br>main.a()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:14 +0xed</span><br></pre></td></tr></table></figure>
<p>main.main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:8 +0x29</span><br></pre></td></tr></table></figure>
<p>使用recover()，主函数输出有序，只是有panic的函数因panic动作，该函数panic后不能继续运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      defer func() &#123;</span><br><span class="line">         if r := recover(); r != nil &#123;</span><br><span class="line">            fmt.Println(&quot;系统出现panic&quot;, r)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>0<br>1<br>2<br>系统出现panic 3<br>hello</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>​    定义指针：</p>
<p>​        var p1 *T</p>
<p>​    &amp;,取地址</p>
<p>​    *,取指针中地址对应的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   /*</span><br><span class="line">   指针：存储另一个变量的内存地址的变量。</span><br><span class="line">   指针的类型，</span><br><span class="line">   指针存储的数据的类型</span><br><span class="line">   指针的地址</span><br><span class="line">   指针存储的变量的地址</span><br><span class="line">    */</span><br><span class="line">    a:=100 //定义了一个变量，变量名：a，变量值：100，变量类型int</span><br><span class="line">    fmt.Printf(&quot;变量的数值：%d，变量的类型：%T\n&quot;,a,a)</span><br><span class="line">    //&amp;,获取变量的内存地址</span><br><span class="line">    fmt.Printf(&quot;变量a的内存地址：%p\n&quot;,&amp;a) //0xc04200e098</span><br><span class="line"></span><br><span class="line">    // 修改变量的值</span><br><span class="line">    a = 200//修改a的数值</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line"></span><br><span class="line">    //创建一个指针</span><br><span class="line">    var p1 *int</span><br><span class="line">    fmt.Println(p1) //&lt;nil&gt; 空 null</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p1) //*int</span><br><span class="line">    fmt.Printf(&quot;p1自己的地址：%p\n&quot;,&amp;p1)</span><br><span class="line">    p1 = &amp;a //取a的地址，赋值给p1</span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">    fmt.Println(&quot;获取数值：&quot;,*p1)</span><br><span class="line"></span><br><span class="line">    // 指针的的指针</span><br><span class="line">    var p2 **int</span><br><span class="line">    fmt.Println(p2) //nil</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p2) //**int</span><br><span class="line">    p2 = &amp;p1 // int--&gt;*int</span><br><span class="line">    fmt.Printf(&quot;p2中存储的数据，就是p1的地址：%p\n&quot;,p2)//p2的值，就是p1的地址</span><br><span class="line">    fmt.Printf(&quot;p2自己的地址：%p\n&quot;,&amp;p2)//p2的地址：</span><br><span class="line"></span><br><span class="line">    fmt.Println(*p1) //*,获取p1指针中存储的内存地址对应的数据。 200</span><br><span class="line">    fmt.Println(*p2) // *p2取值的a的地址</span><br><span class="line">    fmt.Println(**p2)</span><br></pre></td></tr></table></figure>
<p>指针更改数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   a := 100</span><br><span class="line">   p1 := &amp;a</span><br><span class="line">   fmt.Println(a, *p1)//100 100</span><br><span class="line">   *p1++// 操作指针更改变量的数值</span><br><span class="line">   fmt.Println(a, *p1)//101 101</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针及地址打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var a *int</span><br><span class="line">   p:=&amp;a</span><br><span class="line">fmt.Println(*p)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <nil><br>​            0xc042004028</nil></p>
<p>空指针：只声明一个指针不给赋值叫空指针，但是可以给空指针赋值地址，将不再是空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var p *int</span><br><span class="line">   a:=10</span><br><span class="line">   p=&amp;a</span><br><span class="line">   fmt.Println(p)</span><br><span class="line">   fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：0xc04204a080<br>​            10</p>
<h2 id="new-和make-区别"><a href="#new-和make-区别" class="headerlink" title="new()和make()区别"></a>new()和make()区别</h2><p><strong>new()</strong><br>这是一个用来分配内存的内置函数，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配的 t 类型的零值的指针。</p>
<p>在golang的代码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(t Type) *Type</span><br></pre></td></tr></table></figure>
<p>直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针,new()返回值是指针。两者是不一样的</p>
<p>两者对比代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>new()与make()区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">new 主要用于结构体的初始化</span><br><span class="line"></span><br><span class="line">make用于数组array，切片slice，协程chnnel的初始化</span><br><span class="line">例如：  users:=make([10]int);</span><br><span class="line">             msg:=make(chan int);</span><br><span class="line"></span><br><span class="line">     new会分配结构空间，并初始化为清空为零，不进一步初始化</span><br><span class="line">     new之后需要一个指针来指向这个结构</span><br><span class="line">     make会分配结构空间及其附属空间，并完成其间的指针初始化</span><br><span class="line">     make返回这个结构空间，不另外分配一个指针</span><br><span class="line">例子new：</span><br><span class="line">     var p *[]int = new([]int)</span><br><span class="line">     或</span><br><span class="line">     p := new([]int)</span><br><span class="line">     以上分配了一个slice结构，但是结构中的应该指向底层数组的ptr指针为空，故实际不能往这个slice里面存取数据</span><br><span class="line">     同时分配了一个指针p，也即(在32位系统中)占4个字节并存放slice结构的地址</span><br><span class="line">例子make：</span><br><span class="line">     var v []int = make([]int, 0)</span><br><span class="line">     v := make([]int, 0)</span><br><span class="line">     以上分配了一个slice结构，且结构中的应该指向底层数组的ptr指针已经指向了某个底层数组，这个底层数组应该已经分配了，故这个slice已经可以使用了</span><br><span class="line">     注意v就是这个slice结构，而不是一个指向slice的指针</span><br><span class="line">     上述仅是示例，一般使用时都会明确长度和容量：v := make([]int, 10, 50)</span><br><span class="line">结论：</span><br><span class="line">     由上可见，用new来分配slice的意义不大，因为没有恰当的初始化，无法直接使用</span><br><span class="line">     有附带空间的结构，使用make来初始化，可以完成内部指针初始化，其后可以立即使用</span><br></pre></td></tr></table></figure>
<h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct{}"></a>结构体struct{}</h2><p>面向对象：不是一门语言，也不是一门技术，而是一种编程思路。</p>
<p>面向对象：<br>    A：考虑问题域中涉及到的对象<br>    B：定义这些对象—&gt;类<br>    C：思考类和类的关系<br>类，对象：面向对象中的量大核心概念<br>类：同一类事物的抽象描述。<br>    静态属性：字段<br>    动态属性：方法<br>对象：类中一个具体的实例。<br>    对象是存在，<br>类和对象的关系？<br>    类是对象的抽象描述，对象是类的一个具体的实例。<br>    将一类对象共同特征，进行抽取—-&gt;定义类<br>    将类进行实例化—&gt;创建对象<br>type Person struct{<br>    name, age, sex<br>}</p>
<p>p1 := Person{“王二狗”,30,”男”} // 将类进行实例化得到对象。<br>p2 := Preson{“李小花”,18,”女”}<br>面向对象的三大特征：<br>1.封装性：<br>    “打包”<br>    函数，方法，结构体。。。<br>2.继承性：<br>    描述一个类和另一个类的关系。<br>    子类继承父类：<br>        子类可以直接访问父类的属性和方法。<br>        子类可以新增自己的属性和方法<br>        子类可以重写父类已有的方法。<br>    靠结构体的嵌套：<br>        匿名字段：提升字段</p>
<pre><code>3.多态性：接口
</code></pre><p>二.结构体<br>1.定义一个结构体<br>type 结构体名 struct{<br>   字段名 类型<br>}<br>type person1 struct {<br>   name string //姓名<br>   age int // 年龄<br>   sex string // 性别<br>}<br>根据类实例化对象：根据结构体创建该结构体类型的变量</p>
<p>2、创建对象：<br>    对象名 := 结构体名{val1,val2,val3…} //保证顺序<br>        p2 := person1{“李小花”, 18,”女”} //注意赋值顺序<br>    对象名 := 结构体名{字段名:val1,字段名:val2,…}<br>        p3 := person1{age:30,sex:”男”,name:”三胖”}<br>    对象名 := 结构体名{}<br>对象名.字段名 ，进行赋值和取值<br>    var p1 person1<br>    p1.name = “王二狗”<br>p1.age = 30<br>p1.sex = “男”<br>对象名 := new(Type) //指针<br>    p5 := new(person1)<br>fmt.Printf(“%T\n”,p5) //<em>main.person1<br>(</em>p5).name=”隔壁老王”<br>p5.age = 30 // 简写<br>p5.sex = “男”<br>fmt.Println(p5) //&amp;{隔壁老王 30 男}<br>结构体为值类型<br>    结构体：<br>   值类型：<br>      p1 := person{…..}<br>   浅拷贝：<br>      指针：<br>         p2:=new(person)<br>         p3:= &amp;p1<br>3.匿名结构体<br>    匿名结构体和匿名字段<br>           匿名结构体：没有名字的结构体<br>                   匿名字段：没有名字的字段，但是有类型。相当于该类型就是字段名<br>                注意点：一个结构体中，匿名字段的类型是唯一的。<br>                创建结构体对象：<br>           对象名:=结构体名{field:value,field:value…}<br>            结构体的嵌套：<br>           一个结构体作为另一个结构体的字段类型<br>三.结构体的嵌套<br>    继承：两个类的继承关系。子类可以使用父类的功能<br>对于go语言，没有真正的继承。靠结构体的嵌套模拟继承功能的。<br>结构体的嵌套：<br>   聚合关系：一个类作为另一个类的属性。has - a<br>      type A struct{}<br>      type B struct{<br>         a A<br>      }<br>   继承关系：一个子类继承一个父类。is - a<br>      type C struct{}<br>      type D struct{<br>         C<br>      }<br>继承：<br>    子类，父类<br>    子类 继承了父类<br>        1.子类可以直接使用父类的属性和方法。<br>        2.子类可以新增自己的属性和方法<br>        3.子类可以重写父类已有的方法</p>
<pre><code>作用和意义：
    1.可以避免重复的代码。
    2.扩展类的功能。(从父类角度)
</code></pre><h2 id="方法methed"><a href="#方法methed" class="headerlink" title="方法methed"></a>方法methed</h2><h3 id="1-1-什么是方法"><a href="#1-1-什么是方法" class="headerlink" title="1.1 什么是方法"></a>1.1 什么是方法</h3><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集</p>
<p>方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。</p>
<h3 id="1-2-方法的语法"><a href="#1-2-方法的语法" class="headerlink" title="1.2 方法的语法"></a>1.2 方法的语法</h3><p>定义方法的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span> <span class="title">methodName</span><span class="params">(parameter list)</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method has Employee as the receiver type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">displaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">//Calling displaySalary() method of Employee type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以定义相同的方法名</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Area of r1 is: "</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of r2 is: "</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c1 is: "</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c2 is: "</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Area of r1 is:  24</span><br><span class="line">Area of r2 is:  36</span><br><span class="line">Area of c1 is:  314.1592653589793</span><br><span class="line">Area of c2 is:  1963.4954084936207</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过.访问，就像struct里面访问字段一样 </li>
</ul>
<h3 id="1-3-方法和函数"><a href="#1-3-方法和函数" class="headerlink" title="1.3 方法和函数"></a>1.3 方法和函数</h3><p>既然我们已经有了函数，为什么还要使用方法？</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method converted to function with Employee as parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。</p>
</blockquote>
<p>为什么我们可以用函数来写相同的程序呢?有以下几个原因</p>
<ol>
<li>Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。</li>
<li>相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。</li>
</ol>
<h3 id="1-4-变量作用域"><a href="#1-4-变量作用域" class="headerlink" title="1.4 变量作用域"></a>1.4 变量作用域</h3><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p><strong>局部变量</strong></p>
<p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p><strong>全局变量</strong></p>
<p>在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"结果： a = %d, b = %d and g = %d\n"</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果： a = <span class="number">10</span>, b = <span class="number">20</span> and g = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>形式参数</strong></p>
<p>形式参数会作为函数的局部变量来使用</p>
<p><strong>指针作为接收者</strong></p>
<p>若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">SetColor</span><span class="params">(c Color)</span></span> &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>例</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span> <span class="title">setVal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.height = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Rectangle&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := p</span><br><span class="line">	p.setVal()</span><br><span class="line">	fmt.Println(p.height, s.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果没有那个*，则值就是<code>2 2</code></p>
<h3 id="1-5-method继承"><a href="#1-5-method继承" class="headerlink" title="1.5 method继承"></a>1.5 method继承</h3><p>method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam you can call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<h3 id="1-6-method重写"><a href="#1-6-method重写" class="headerlink" title="1.6 method重写"></a>1.6 method重写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam, I work at Golang Inc. Call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<ul>
<li>方法是可以继承和重写的</li>
<li>存在继承关系时，按照就近原则，进行调用</li>
</ul>
<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><h3 id="一-error"><a href="#一-error" class="headerlink" title="一.error"></a>一.error</h3><pre><code>异常：不正常，程序中存在不正常的事件，导致程序无法正常的执行。
error,错误，来表示程序中的不正常。
    函数() 返回值：error
error 本质上是一个接口，所有能实现 函数名为Error（）返回值为string 方法的结构体都是error的实现类。
    type error interface {
       Error() string
    }
go语言中提供两个函数来实现 返回值string
  errors.New(string)--&gt;error
  fmt.Errorf(format)--&gt;error
error：nil，表示没有错误    
error：Go中表示不正常的错误的类型。

1.2自定义error的实现类
    1.定义一个结构体，实现error接口。即该结构体有个如下的方法
        func (s struct)Error() string{
        //该函数中的返回值string 可以用 fmt.Sprintf()函数实现。改函数即将打印的内            
        容转为string类型
        }
    2：使用--&gt;
                创建error对象，创建自定义实现类的对象即可。
</code></pre><h3 id="二-strconv：字符串和基本类型之间的转换"><a href="#二-strconv：字符串和基本类型之间的转换" class="headerlink" title="二.strconv：字符串和基本类型之间的转换"></a>二.strconv：字符串和基本类型之间的转换</h3><pre><code>string与其他数据类型的转换
</code></pre><p>string–&gt;int,float64,bool….<br>   ParseXXX()<br>      ParseInt(),ParseBool(),ParseFloat()</p>
<p>int,float,bool—&gt;string<br>      FormatXXX()<br>      FormatBool(),FormatInt(),FormatFloat()</p>
<p>Atoi(string)–&gt;int,10进制<br>Itoa(int)–&gt;string,10进制整数–&gt;字符串<br>​    </p>
<h3 id="三-math包"><a href="#三-math包" class="headerlink" title="三.math包"></a>三.math包</h3><p>fmt.Println(math.Abs(float64(i))) //绝对值<br>fmt.Println(math.Ceil(5.0))       //向上取整<br>fmt.Println(math.Floor(5.8))      //向下取整<br>fmt.Println(math.Mod(11, 3))      //取余数，同11%3<br>fmt.Println(math.Modf(5.26))      //取整数，取小数<br>fmt.Println(math.Pow(3, 2))       //x的y次方<br>fmt.Println(math.Pow10(4))        // 10的n次方<br>fmt.Println(math.Sqrt(8))         //开平方<br>fmt.Println(math.Cbrt(8))         //开立方</p>
<h3 id="四-time包"><a href="#四-time包" class="headerlink" title="四.time包"></a>四.time包</h3><pre><code>1.获取时间对象
t1 := time.Now() // 当前的时间
2.创建指定的时间
</code></pre><p>t2 := time.Date(1998,4,12,16,34,0,0,time.Local)<br>fmt.Println(t2)<br>//获取日期<br> year,month,day:=t1.Date()<br> fmt.Println(“年，月，日：”,year,month,day)<br> //获取时间<br> hour,minute,second := t1.Clock()<br> fmt.Println(“时，分，秒：”, hour,minute,second)<br>//获取年，月，日，时，分，秒，星期，纳秒，。。<br>fmt.Println(“年：”, t1.Year()) //年<br>fmt.Println(“月：”,t1.Month())//月<br>fmt.Println(“日：”,t1.Day())//日<br>fmt.Println(“时：”,t1.Hour())//时<br>fmt.Println(“分：”,t1.Minute())//分<br>fmt.Println(“秒：”,t1.Second())//秒<br>fmt.Println(“纳秒：”,t1.Nanosecond())//纳秒<br>fmt.Println(“星期：”,t1.Weekday())//星期<br>fmt.Println(t1.ISOWeek()) //返回年份，第几周<br>fmt.Println(t1.YearDay())<br>//timestamp,时间戳：<br>日期，距离1970年1月1日，0点0时，0分0秒，时间的差值<br>    timeStamp1:=t4.Unix() //秒 差值 3600<br>            timeStamp2:=t4.UnixNano()//纳秒</p>
<pre><code>Duration,时间间隔
t1 := time.Now()
        t2 := t1.Add(time.Nanosecond)//在当前时间上，累加1纳秒，nanosecond即为1
        t3 := t1.Add(time.Minute)// 当前时间上，累加1分钟
        t4:=t1.Add(time.Hour * 24)//当前时间，类加1天
        t5:=t1.AddDate(0,0,3)//累加：年，月，日
</code></pre><p>//两个time之间的间隔<br>    d1:= t1.Sub(t5) //t1-t2<br>//睡眠<br>//time.Sleep(time.Nanosecond)//睡眠1纳秒<br>//time.Sleep(5 * time.Second) //当前正在执行的程序进入睡眠。。<br>//fmt.Println(“over….”)</p>
<p>//睡眠，随机数：[1-10]s<br>// [m,n], rand.Intn(n-m+1)+m<br>rand.Seed(time.Now().UnixNano())<br>num := rand.Intn(10) + 1 //<br>fmt.Println(num)<br>time.Sleep(time.Duration(num) * time.Second)<br>fmt.Println(“睡眠结束。。。”)</p>
<h2 id="文件读写-read-write"><a href="#文件读写-read-write" class="headerlink" title="文件读写 read()  write()"></a>文件读写 read()  write()</h2><p>一.文件，路径</p>
<pre><code>文件，目录
目录：directory
    文件存储的路径位置。
文件：file
    用于存储数据，靠文件的类型存储不同类型的数据。
数据存储：
    程序执行过程中产生的数据：存储在内存中。---&gt;瞬时性。
    文件，硬盘上。持久化存储数据。
程序的执行：
    CPU，内存
文件路径：
    绝对路径：
        从跟盘符开始的路径。
    相对路径：
        参照物。go里面以当前的项目的路径，为相对路径的参照物。
</code></pre><p>二.os包：文件操作<br>文件的信息可以读取进一个[]byte切片。Read和Write方法从切片参数获取其内的字节数。<br>    1.os.Stat<br>    os.Stat(“pathname”)<br>    返回值有两个<br>    fi ：<br>         type FileInfo interface {<br>            Name() string       // 文件的名字（不含扩展名）<br>            Size() int64        // 普通文件返回值表示其大小；其他文件的返回值<br>                                含义各系统不同<br>           Mode() FileMode     // 文件的模式位<br>            ModTime() time.Time // 文件的修改时间<br>            IsDir() bool        // 等价于Mode().IsDir()<br>            Sys() interface{}   // 底层数据来源（可以返回nil）<br>      }<br>    err：该文件路径不正确返回的值<br>2.os.mkdir(“pathname”)–&gt;创建文件，仅一层<br>  os.mkdirall(“pathname”)–&gt;创建文件，可以多层<br>      os.create(“pathname”) <em>file,err–&gt;创建空文件<br>      os.open()</em>file,err–&gt;打开文件<br>  os.remove(),删除文件或文件夹，慎用！！！！<br>      os.removeall(),删除所有，慎用！！！！<br>3.关闭文件<br>defer file.Close()//断开程序和文件之间的链接，释放资源。<br>// 读操作，写数据。。。<br>4.os.Open(“文件名”)–&gt;file指针对象<br>Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是<em>PathError。<br>    表示程序中打开文件，和文件建立连接，可以操作文件了。<br>    就是操作file对象，就是操作文件。。<br>os.OpenFile<br>    OpenFile(filename，flag，perm)–&gt;</em>File,err  <strong>*</strong><br>            filename：文件名字<br>            flag，获取file的打开模式：<br>                O_RDONLY<br>                O_WRONLY<br>                O_RDWR<br>                O_CREATE</p>
<pre><code>perm，如果文件不存在，需要指定创建的文件的权限
    0777,0666
    -rw-
</code></pre><p>5.文件读写<em>**<br>    Read([]byte)–&gt;count,err，读取数据<br>默认从头开始读取<br>   光标在最后，再次读取，返回error为io.EOF<br>    func (f </em>File) Read(b []byte) (n int, err error)<br>    Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。</p>
<pre><code>ReadAt([] byte, off)--&gt;coutn,err，从指定off位置读取
    unc (f *File) ReadAt(b []byte, off int64) (n int, err error)
ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。

Write([]byte)--&gt;count,err，写出字节数组
    func (f *File) Write(b []byte) (n int, err error)
Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteAt([]byte,off)，在指定位置写出数据。
    func (f *File) WriteAt(b []byte, off int64) (n int, err error)
    WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteString(string)，直接写出字符串
    func (f *File) WriteString(s string) (ret int, err error)
    WriteString类似Write，但接受一个字符串参数。

Seek(offset, whence)，设置光标的未知
    offset,偏移量
    whence，从哪开始：0从头，1当前，2末尾

    filepath包
        Abs()
            获取绝对路径：程序中以当前工程为参照。
        IsAbs()
            判断是否是绝对路径

        绝对路径：Absolute
            从跟盘符开始描述

        相对路径：Relative
            相对于参照物
</code></pre><p>三.io/ioutil包<br>    io包<br>        Copy(Write，Reader)–&gt;total,err<br>            拷贝文件<br>        func copyFile2(destName, srcName string)(int64, error){<br>   srcFile ,err:= os.Open(srcName)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer srcFile.Close()<br>   destFile,err:=os.OpenFile(destName,os.O_WRONLY|os.O_CREATE,0777)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer destFile.Close()<br>   return io.Copy(destFile,srcFile)<br>}</p>
<p>ioUtil包<br>    ReadFile(filename)–&gt;data []byte   <strong>*</strong><br>        读取指定文件中的所有内容<br>    WriteFile(filename, data [] byte,FileMode) <strong>*</strong><br>        向指定文件中写出数据，</p>
<pre><code>ReadAll()

ReadDir(dirname)--&gt;[]FileInfo
    获取指定目录下的子内容，只有一层
</code></pre><p>​<br>​<br>​<br>​        </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'images/wechat.jpg',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
            
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/17/012+公钥加密/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2018/04/21/第18章-反射/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">反射reflect</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang细节汇总"><span class="nav-number">1.</span> <span class="nav-text">Golang细节汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mac-goland-安装"><span class="nav-number">1.1.</span> <span class="nav-text">mac goland 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原码，反码，补码"><span class="nav-number">1.2.</span> <span class="nav-text">原码，反码，补码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-fallthrough用法"><span class="nav-number">1.3.</span> <span class="nav-text">switch fallthrough用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-语句"><span class="nav-number">1.4.</span> <span class="nav-text">select 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice-array切片和数组的创建"><span class="nav-number">1.5.</span> <span class="nav-text">slice,array切片和数组的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice-copy和append方法"><span class="nav-number">1.6.</span> <span class="nav-text">slice copy和append方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-字典"><span class="nav-number">1.7.</span> <span class="nav-text">Map 字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string字符串"><span class="nav-number">1.8.</span> <span class="nav-text">string字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#func（）函数"><span class="nav-number">1.9.</span> <span class="nav-text">func（）函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic-和recover"><span class="nav-number">1.10.</span> <span class="nav-text">panic()和recover()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-number">1.11.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-和make-区别"><span class="nav-number">1.12.</span> <span class="nav-text">new()和make()区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体struct"><span class="nav-number">1.13.</span> <span class="nav-text">结构体struct{}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法methed"><span class="nav-number">1.14.</span> <span class="nav-text">方法methed</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-什么是方法"><span class="nav-number">1.14.1.</span> <span class="nav-text">1.1 什么是方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-方法的语法"><span class="nav-number">1.14.2.</span> <span class="nav-text">1.2 方法的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-方法和函数"><span class="nav-number">1.14.3.</span> <span class="nav-text">1.3 方法和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-变量作用域"><span class="nav-number">1.14.4.</span> <span class="nav-text">1.4 变量作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-method继承"><span class="nav-number">1.14.5.</span> <span class="nav-text">1.5 method继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-method重写"><span class="nav-number">1.14.6.</span> <span class="nav-text">1.6 method重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包package"><span class="nav-number">1.15.</span> <span class="nav-text">包package</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-error"><span class="nav-number">1.15.1.</span> <span class="nav-text">一.error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-strconv：字符串和基本类型之间的转换"><span class="nav-number">1.15.2.</span> <span class="nav-text">二.strconv：字符串和基本类型之间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-math包"><span class="nav-number">1.15.3.</span> <span class="nav-text">三.math包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-time包"><span class="nav-number">1.15.4.</span> <span class="nav-text">四.time包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写-read-write"><span class="nav-number">1.16.</span> <span class="nav-text">文件读写 read()  write()</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 Hexo All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

<!-- Custome JS -->
<script src="/js/my.js"></script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
