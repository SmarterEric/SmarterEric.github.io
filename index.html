<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <!-- PACE Progress Bar START -->
  
    <script src="/js/pace.min.js"></script>
    <link rel="stylesheet" href="https://github.com/HubSpot/pace/raw/master/themes/orange/pace-theme-flash.css">
  
  

  <!-- PACE Progress Bar START -->

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/my.css">
  <!-- Google Adsense -->
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
      (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-0123456789ABCDEF",
          enable_page_level_ads: true
      });
  </script>
</head>

<script>
var themeMenus = {};

  themeMenus["/"] = "首页"; 

  themeMenus["/archives"] = "归档"; 

  themeMenus["/categories"] = "分类"; 

  themeMenus["/tags"] = "标签"; 

  themeMenus["/about"] = "关于"; 

</script>


  <body>


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Hexo" rel="home"> Hexo </a>
            
          </h1>

          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>


  <div id="originBgDiv" style="background: #fff; width: 100%;">

      <div style="max-height:600px; overflow: hidden;  display: flex; display: -webkit-flex; align-items: center;">
        <img id="originBg" width="100%" alt="" src="">
      </div>

  </div>

  <script>
  function setAboutIMG(){
      var imgUrls = "css/images/pose.jpg,https://source.unsplash.com/collection/954550/1920x1080".split(",");
      var random = Math.floor((Math.random() * imgUrls.length ));
      if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
        document.getElementById("originBg").src=imgUrls[random];
      } else {
        document.getElementById("originBg").src='/' + imgUrls[random];
      }
  }
  bgDiv=document.getElementById("originBgDiv");
  if(location.pathname.match('about')){
    setAboutIMG();
    bgDiv.style.display='block';
  }else{
    bgDiv.style.display='none';
  }
  </script>



  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-虚拟货币的认识"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/06/11/虚拟货币的认识/" class="article-date">
	  <time datetime="2018-06-11T09:21:56.696Z" itemprop="datePublished">六月 11, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="虚拟货币的认识"><a href="#虚拟货币的认识" class="headerlink" title="虚拟货币的认识"></a>虚拟货币的认识</h1><p>##初识比特币</p>
<p>  比特币的出现确实是一个挑战时代底线的一个新鲜事物，它几乎颠覆了人民的传统观念，我刚开始接触它的时候非常抵触，当慢慢地融入到这个圈里，并开始学习真正的区块链，看了很多这方面的书籍和研究比特币及以太坊的源码，了解了大家常说的“去中心化”，“分布式”，“P2P交易”，“数据加密”,”数字签名”，“公链”，“私链”等等,以及炒币词汇，如“割韭菜”，“梭哈”，“割肉”，“代币”，“法币”，“庄家”，“挖矿”等等。更是通过炒币巨亏，使自己变得更加强大了，而且自己已经变成了一个虚拟货币的信仰者。</p>
<p>##简单介绍学习和研究的东西</p>
<p>1.去中心化：存储数据到足够多的节点上，而且这些存储的数据是一样的，这样就保证了数据的一致性。如果想更改数据，那么理论上你需要更改超过51%的节点上的数据，那么所有节点将会改变原来的数据，更改成功。可是你想改变超过51%的节点数据根本不可能，成本不可估算。这就是区块链数据的不可篡改性，也就是去中心化。</p>
<p>2.挖矿：挖矿的共识算法主要有pow，pos，dpos。现在大部分挖矿算法是pow。按比特币分析：比特币的总量是2100万个。原理是每隔大约10分钟产生一个区块，也就是每次产生一个区块需要耗时10分钟左右。在这个产生新区块的10分钟时间内。这个10分钟的来源就是挖矿的时间。现在挖矿难度是生成的有效hash值前面满足19个0，当然这个难度值是变化的，总体保证挖矿时间维持在10分钟左右。同时挖矿的奖励每隔4年减半1次。在这挖矿的10分中内有很多笔交易需要打包，这些交易有之前的也有现在正在产生的。通过一些算法考量这些打包好的数据哪些先被放到区块里，哪些继续留在交易池里。挖矿时间开始，那么数据将停止存储，运用sha256加密方法给当前区块进行hash运算，一直得到有效hash值，标志着该区块成为有效的区块，也就是挖矿出来的新的区块。将该区块存储到区块链上。</p>
<p> 3.P2P交易：这个很容易理解，就是用户之间进行的交易，不存在什么中介，中间转移。1对1交易。</p>
<p>  4.数据加密：类型有对称加密和非对称加密。对称加密就是可以对明文加密成密文，也可以将密文解密成明文，也就是公钥加密，私钥解密。往往用在数据签名验签，传输文件，存储数据等。非对称加密主要用在生成钱包上面，如下边解析：<br>              创建一个钱包地址<br>        1）生成一对公钥和私钥<br>        2）想要获取地址，可以通过公钥进行Base58编码<br>        3）想要别人给我转账，把地址给别人，对地址进行反编码，变成公钥。将公钥和数据进行签名<br>        4）通过私钥进行解密，解密是单方向的，只有拥有私钥的人才能解密</p>
<p>5.分布式账本：目前eos拥有21个超级节点，目的是更快的存储和同步数据。这21个超级节点谁成为主节点的顺序是随机的，为的是防止他们篡改数据。每个超级节点自己本身是自己覆盖区域的主节点，其他节点向其递交数据，当递交的数据超过51%的节点都有存储后，该数据才有效，那么主节点存储该数据，同时不断给那些没存储该数据的节点发送信号，让它更新数据，保证和主节点数据一致。</p>
<p>6.公链，私链，联盟链：公有链是指全世界任何人都可读取的、任何人都能发送交易且交易能获得有效确认的、任何人都能参与其中共识过程的区块链——共识过程决定哪个区块可被添加到区块链中和明确当前状态。公有链通常被认为是“完全去中心化”的。私有链是公司内部或者社团内部使用的区块链。联盟链也就是约定好的几家公司或社团内部使用的区块链。<br>    公有链：对所有人开放，任何人都可以参与;<br>    联盟链：对特定的组织团体开放;<br>    私有链：对单独的个人或实体开放。</p>
<p>7.区块链层级结构：整体结构包括有6个，包括数据层，网络层，共识层，激励层，合约层，应用层。其中数据层，网络层，共识层是构建区块链技术的必要元素，这三个缺少任何一层，都不能成为真正意义上的区块链技术。另外三层则在不同项目，可以各不相同。激励层就是设计激励政策，鼓励用户参与到区块链生态中；合约层一般指“智能合约”，它是一套可以自动执行，随意编写的合约体系。应用层就是区块链上的应用程序，与手机系统上的app类似。</p>
<p>##对初链的了解</p>
<p>通过浏览初链白皮书和黄皮书，感觉项目整体很不错，深入运用区块链技术，将部分应用部署在平台上。初链团队是一个靠谱的团队，通过这次活动集结区块链人才，集思广益，定有很好的未来。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-分布式终端与go编程添加和删除节点"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/29/分布式终端与go编程添加和删除节点/" class="article-date">
	  <time datetime="2018-05-29T12:38:20.142Z" itemprop="datePublished">五月 29, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式终端与go编程添加和删除节点"><a href="#分布式终端与go编程添加和删除节点" class="headerlink" title="分布式终端与go编程添加和删除节点"></a>分布式终端与go编程添加和删除节点</h1><p>##1.首先在终端执行起来一个节点<br>./etcd –name htcd0 –initial-advertise-peer-urls <a href="http://127.0.0.1:2380" target="_blank" rel="noopener">http://127.0.0.1:2380</a> –listen-peer-urls <a href="http://127.0.0.1:2380" target="_blank" rel="noopener">http://127.0.0.1:2380</a> –listen-client-urls tp://127.0.0.1:2379 –advertise-client-urls <a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> –initial-cluster-token etcd-cluster-1 –initial-cluster cd0=<a href="http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580" target="_blank" rel="noopener">http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580</a> –initial-cluster-state new<br>上边的127.0.0.1:2380是终端执行的节点url<br>而127.0.0.1:2379的节点是2380端口节点要监听的节点。</p>
<p>为上边的执行命令做个解析：<br>–name<br>etcd集群中的节点名，这里可以随意，可区分且不重复就行<br>–listen-peer-urls<br>监听的用于节点之间通信的url，可监听多个，集群内部将通过这些url进行数据交互(如选举，数据同步等)<br>–initial-advertise-peer-urls<br>建议用于节点之间通信的url，节点间将以该值进行通信。<br>–listen-client-urls<br>监听的用于客户端通信的url,同样可以监听多个。<br>–advertise-client-urls<br>建议使用的客户端通信url,该值用于etcd代理或etcd成员与etcd节点通信。<br>–initial-cluster-token etcd-cluster-1<br>节点的token值，设置该值后集群将生成唯一id,并为每个节点也生成唯一id,当使用相同配置文件再启动一个集群时，只要该token值不一样，etcd集群就不会相互影响。<br>–initial-cluster<br>也就是集群中所有的initial-advertise-peer-urls 的合集<br>–initial-cluster-state new<br>新建集群的标志，初始化状态使用 new，建立之后改此值为 existing</p>
<p>##2.再在终端开启2个节点，组成一个集群<br>./etcd –name cd1 –initial-advertise-peer-urls <a href="http://127.0.0.1:2480" target="_blank" rel="noopener">http://127.0.0.1:2480</a> –listen-peer-urls <a href="http://127.0.0.1:2480" target="_blank" rel="noopener">http://127.0.0.1:2480</a> –listen-client-urls <a href="http://127.0.0.1:2479" target="_blank" rel="noopener">http://127.0.0.1:2479</a> –advertise-client-urls <a href="http://127.0.0.1:2479" target="_blank" rel="noopener">http://127.0.0.1:2479</a> –initial-cluster-token etcd-cluster-1 –initial-cluster cd0=<a href="http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580" target="_blank" rel="noopener">http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580</a> –initial-cluster-state new<br>这段命令是添加第二个节点，也可以通过go编程添加节点，只不过要用2479这个url通讯<br>./etcd –name cd2 –initial-advertise-peer-urls <a href="http://127.0.0.1:2580" target="_blank" rel="noopener">http://127.0.0.1:2580</a> –listen-peer-urls <a href="http://127.0.0.1:2580" target="_blank" rel="noopener">http://127.0.0.1:2580</a> –listen-client-urls <a href="http://127.0.0.1:2579" target="_blank" rel="noopener">http://127.0.0.1:2579</a> –advertise-client-urls <a href="http://127.0.0.1:2579" target="_blank" rel="noopener">http://127.0.0.1:2579</a> –initial-cluster-token etcd-cluster-1 –initial-cluster cd0=<a href="http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580" target="_blank" rel="noopener">http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580</a> –initial-cluster-state new<br>执行第三个节点，用2579通讯</p>
<p>##3.查询 member 列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line">ENDPOINTS=127.0.0.1:2379,127.0.0.1:2479,127.0.0.1:2579</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>##4.添加 member 节点</p>
<p><strong>member add</strong> 添加节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member add cd3 --peer-urls=http://127.0.0.1:2180</span><br><span class="line">Member b9057cfdc8ff17ce added to cluster 9da8cd75487bd6dc</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ETCD_NAME=&quot;cd3&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;cd2=http://127.0.0.1:2580,cd3=http://127.0.0.1:2180,cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://127.0.0.1:2180&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot;</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">b9057cfdc8ff17ce, unstarted, , http://127.0.0.1:2180, </span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>通过查询结果可以发现：<code>http://127.0.0.1:2180</code> 显示状态为：<code>unstarted</code> </p>
<p><strong>启动新节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd --name cd3 --listen-client-urls http://127.0.0.1:2179 --advertise-client-urls http://127.0.0.1:2179 --listen-peer-urls http://127.0.0.1:2180 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2580,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">b9057cfdc8ff17ce, started, cd3, http://127.0.0.1:2180, http://127.0.0.1:2179</span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>##5.删除 member</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member remove 21a304d74d267837</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Member b9057cfdc8ff17ce removed from cluster 9da8cd75487bd6dc</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>##6.</p>
<h2 id="添加-member-节点"><a href="#添加-member-节点" class="headerlink" title="添加 member 节点"></a>添加 member 节点</h2><p><strong>member add</strong> 添加节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member add cd3 --peer-urls=http://127.0.0.1:2180</span><br><span class="line">Member b9057cfdc8ff17ce added to cluster 9da8cd75487bd6dc</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ETCD_NAME=&quot;cd3&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;cd2=http://127.0.0.1:2580,cd3=http://127.0.0.1:2180,cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://127.0.0.1:2180&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot;</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">b9057cfdc8ff17ce, unstarted, , http://127.0.0.1:2180, </span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>通过查询结果可以发现：<code>http://127.0.0.1:2180</code> 显示状态为：<code>unstarted</code> </p>
<p><strong>启动新节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd --name cd3 --listen-client-urls http://127.0.0.1:2179 --advertise-client-urls http://127.0.0.1:2179 --listen-peer-urls http://127.0.0.1:2180 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2580,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">b9057cfdc8ff17ce, started, cd3, http://127.0.0.1:2180, http://127.0.0.1:2179</span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<h2 id="删除-member"><a href="#删除-member" class="headerlink" title="删除 member"></a>删除 member</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member remove 21a304d74d267837</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Member b9057cfdc8ff17ce removed from cluster 9da8cd75487bd6dc</span><br></pre></td></tr></table></figure>
<p><strong>查询 member 节点列表信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">98f0c6bf64240842, started, cd2, http://127.0.0.1:2580, http://127.0.0.1:2579</span><br><span class="line">bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379</span><br><span class="line">e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479</span><br></pre></td></tr></table></figure>
<p>##7.执行go程序代码，增加或者删除节点<br>package main</p>
<p>import (<br>    “github.com/coreos/etcd/clientv3”<br>    “context”<br>    “fmt”<br>    “time”<br>)</p>
<p>//通过代码向网络添加和删除节点，配置这台电脑的url和超时保护<br>var (<br>    dialTimeout=5<em>time.Second<br>    requestTimeout=2</em>time.Second<br>    endPoints=[]string{“127.0.0.1:2379”}<br>)</p>
<p>//添加节点<br>func addMember(cli *clientv3.Client,url string)  {<br>    peerURLs:=[]string {url}<br>    //向系统中插入节点<br>    _,err:=cli.MemberAdd(context.Background(),peerURLs)<br>    if err!=nil{<br>        fmt.Println(“memberadd”,err)<br>    }<br>    //显示插入的节点<br>    resp,err:=cli.MemberList(context.Background())<br>    if err!=nil{<br>        fmt.Println(“memberlist”,err)<br>    }<br>    fmt.Println(“添加后的members为”,resp.Members)</p>
<p>}<br>func main()  {<br>    //运行之前终端先开启一个节点，再执行下边的代码，来链接终端那侧的节点，链接后这个cli其实就是个中介的角色，下边再进行给创建及删除节点，<br>    //新建的节点与终端执行的节点组成集群。<br>    cli,err:=clientv3.New(clientv3.Config{<br>        Endpoints:endPoints,<br>        DialTimeout:dialTimeout,<br>    })<br>    if err!=nil{<br>        fmt.Println(“clientv3 new”,err)<br>    }</p>
<pre><code>fmt.Println(&quot;cli.Cluster:&quot;,cli)

defer cli.Close()
//添加新节点
addMember(cli,&quot;127.0.0.1:2180&quot;)
addMember(cli,&quot;127.0.0.1:2181&quot;)
addMember(cli,&quot;127.0.0.1:2182&quot;)
//删除节点
//delMember(cli,0xe32088547caa8215)
</code></pre><p>}<br>//删除节点<br>func delMember(cli *clientv3.Client,memberId uint64)  {<br>    _,err:=cli.MemberRemove(context.Background(),memberId)<br>    if err!=nil{<br>        fmt.Println(“delMember”,err)<br>    }else {<br>        fmt.Printf(“删除节点%s成功了\n”,memberId)<br>    }<br>}</p>
<p>执行go编程创建的节点连接到集群，但是处于unstarted的状态<br>执行完 添加节点，需要打开终端启动节点服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd --name cd3 --listen-client-urls http://127.0.0.1:2179 --advertise-client-urls http://127.0.0.1:2179 --listen-peer-urls http://127.0.0.1:2180 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2580,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-分布式"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/29/分布式/" class="article-date">
	  <time datetime="2018-05-29T01:37:01.622Z" itemprop="datePublished">五月 29, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>##etcd - 一个分布式一致性键值存储系统</p>
<p>etcd是一个分布式一致性键值存储系统，用于共享配置和服务发现，专注于：</p>
<ul>
<li><p>简单:良好定义的，面向用户的API (gRPC)</p>
</li>
<li><p>安全： 带有可选客户端证书认证的自动TLS</p>
</li>
<li><p>快速:测试验证，每秒10000写入</p>
</li>
<li><p>可靠:使用Raft适当分布</p>
</li>
</ul>
<p>etcd是Go编写，并使用Raft一致性算法来管理高可用复制日志，架构如下图所示：</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//新建文件coreos</span><br><span class="line">$ mkdir -p $GOPATH/src/github.com/coreos</span><br><span class="line">//进到coreos目录下</span><br><span class="line">$ cd coreos</span><br><span class="line">$ git clone https://github.com/coreos/etcd.git</span><br><span class="line">$ cd etcd</span><br><span class="line">$ ./build</span><br><span class="line">$ ./bin/etcd</span><br></pre></td></tr></table></figure>
<p>另外一种下载安装的方法：</p>
<p>直接下载etcd二进制 （包含etcd、etcdctl）<br><a href="https://github.com/coreos/etcd/releases" target="_blank" rel="noopener">https://github.com/coreos/etcd/releases</a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//进入到coreos下的etcd目录下</span><br><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd</span><br><span class="line">//执行之前编译的etcd</span><br><span class="line">$ ./bin/etcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//新开一个终端</span><br><span class="line">//进入etcd目录下</span><br><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd</span><br><span class="line">$ ETCDCTL_API=3 ./bin/etcdctl put foo bar</span><br><span class="line"></span><br><span class="line"># 输出结果显示OK，表示安装成功</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="搭建本地集群"><a href="#搭建本地集群" class="headerlink" title="搭建本地集群"></a>搭建本地集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装多进程管理工具</span><br><span class="line">$ go get github.com/mattn/goreman</span><br><span class="line"></span><br><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd</span><br><span class="line">$ goreman -f Procfile start</span><br></pre></td></tr></table></figure>
<p>查看本地集群的服务器列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl member list</span><br><span class="line"></span><br><span class="line"># 显示结果</span><br><span class="line"></span><br><span class="line">8211f1d0f64f3269: name=infra1 peerURLs=http://127.0.0.1:12380 clientURLs=http://127.0.0.1:2379 isLeader=false</span><br><span class="line">91bc3c398fb3c146: name=infra2 peerURLs=http://127.0.0.1:22380 clientURLs=http://127.0.0.1:22379 isLeader=true</span><br><span class="line">fd422379fda50e48: name=infra3 peerURLs=http://127.0.0.1:32380 clientURLs=http://127.0.0.1:32379 isLeader=false</span><br></pre></td></tr></table></figure>
<h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl put foo &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl get foo</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl  --write-out=&quot;json&quot; get foo</span><br><span class="line"></span><br><span class="line">&#123;&quot;header&quot;:&#123;&quot;cluster_id&quot;:17237436991929493444,&quot;member_id&quot;:9372538179322589801,&quot;revision&quot;:2,&quot;raft_term&quot;:2&#125;,&quot;kvs&quot;:[&#123;&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:2,&quot;mod_revision&quot;:2,&quot;version&quot;:1,&quot;value&quot;:&quot;SGVsbG8gV29ybGQh&quot;&#125;],&quot;count&quot;:1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据前缀查询"><a href="#根据前缀查询" class="headerlink" title="根据前缀查询"></a>根据前缀查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ./bin/etcdctl put web1 value1</span><br><span class="line">$ ./bin/etcdctl put web2 value2</span><br><span class="line">$ ./bin/etcdctl put web3 value3</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl get web --prefix</span><br><span class="line"></span><br><span class="line">web1</span><br><span class="line">value1</span><br><span class="line">web2</span><br><span class="line">value2</span><br><span class="line">web3</span><br><span class="line">value3</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/etcdctl put key myvalue</span><br><span class="line">$ ./bin/etcdctl del key</span><br><span class="line">1</span><br><span class="line">$ ./bin/etcdctl get key</span><br><span class="line">// 查询结果为空</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl put k1 value1</span><br><span class="line">$ ./bin/etcdctl put k2 value2</span><br><span class="line">$ ./bin/etcdctl del k --prefix</span><br><span class="line">2</span><br><span class="line">$ ./bin/etcdctl get k --prefix</span><br><span class="line">// 查询结果为空</span><br></pre></td></tr></table></figure>
<h3 id="事务写入"><a href="#事务写入" class="headerlink" title="事务写入"></a>事务写入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/etcdctl put user1 bad</span><br><span class="line">OK</span><br><span class="line">$ ./bin/etcdctl txn --interactive//进行事物交互</span><br><span class="line"></span><br><span class="line">compares:</span><br><span class="line">// 输入以下内容，输入结束按 两次回车</span><br><span class="line">value(&quot;user1&quot;) = &quot;bad&quot;      </span><br><span class="line"></span><br><span class="line">//如果 user1 = bad，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != bad，则执行 put user1 good</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 good</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 success</span><br><span class="line">SUCCESS</span><br><span class="line"></span><br><span class="line">user1</span><br><span class="line">bad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl txn --interactive</span><br><span class="line">compares:</span><br><span class="line">value(&quot;user1&quot;) = &quot;111&quot;  </span><br><span class="line"></span><br><span class="line">// 如果 user1 = 111，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != 111，则执行 put user1 2222</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 2222</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 failure</span><br><span class="line">FAILURE</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl get user1</span><br><span class="line">user1</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知</span><br><span class="line">$ ./bin/etcdctl watch stock1</span><br><span class="line"></span><br><span class="line">// 新打开终端</span><br><span class="line">$ export ETCDCTL_API=3</span><br><span class="line">$ ./bin/etcdctl put stock1 1000</span><br><span class="line"></span><br><span class="line">//在watch 终端显示</span><br><span class="line">PUT</span><br><span class="line">stock1</span><br><span class="line">1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl watch stock --prefix</span><br><span class="line">$ ./bin/etcdctl put stock1 10</span><br><span class="line">$ ./bin/etcdctl put stock2 20</span><br></pre></td></tr></table></figure>
<h3 id="lease-租期"><a href="#lease-租期" class="headerlink" title="lease//租期"></a>lease//租期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在bin目录下./bin</span><br><span class="line">$ ./etcdctl lease grant 300</span><br><span class="line"># lease 326963a02758b527 granted with TTL(300s)</span><br><span class="line"></span><br><span class="line">$ ./etcdctl put sample value -- lease=326963a02758b527</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./etcdctl get sample</span><br><span class="line"></span><br><span class="line">$ ./etcdctl lease keep-alive 326963a02758b520</span><br><span class="line">$ ./etcdctl lease revoke 326963a02758b527//撤权</span><br><span class="line">lease 326963a02758b527 revoked</span><br><span class="line"></span><br><span class="line"># or after 300 seconds</span><br><span class="line">$ ./etcdctl get sample</span><br></pre></td></tr></table></figure>
<h3 id="Distributed-locks"><a href="#Distributed-locks" class="headerlink" title="Distributed locks"></a>Distributed locks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一终端</span><br><span class="line">$ ./etcdctl lock mutex1</span><br><span class="line">mutex1/326963a02758b52d</span><br><span class="line"></span><br><span class="line"># 第二终端</span><br><span class="line">$ ./etcdctl lock mutex1</span><br><span class="line"></span><br><span class="line">// 当第一个终端结束了用命令control C停止，第二个终端会显示</span><br><span class="line">mutex1/326963a02758b531</span><br></pre></td></tr></table></figure>
<h3 id="Elections"><a href="#Elections" class="headerlink" title="Elections"></a>Elections</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/etcdctl elect one p1</span><br><span class="line"></span><br><span class="line">one/326963a02758b539</span><br><span class="line">p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># another client with the same name blocks</span><br><span class="line">$ ./bin/etcdctl elect one p2</span><br><span class="line"></span><br><span class="line">//结束第一终端，第二终端显示</span><br><span class="line">one/326963a02758b53e</span><br><span class="line">p2</span><br></pre></td></tr></table></figure>
<h3 id="Cluster-status"><a href="#Cluster-status" class="headerlink" title="Cluster status"></a>Cluster status</h3><p>集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/etcdctl --write-out=table endpoint status</span><br><span class="line"></span><br><span class="line">$ ./bin/etcdctl endpoint health</span><br></pre></td></tr></table></figure>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./bin/etcdctl snapshot save my.db</span><br><span class="line"></span><br><span class="line">Snapshot saved at my.db</span><br><span class="line"></span><br><span class="line">./bin/etcdctl --write-out=table snapshot status my.db</span><br></pre></td></tr></table></figure>
<h3 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/etcdctl member list -w table</span><br></pre></td></tr></table></figure>
<p>##etcd 多台服务器集群</p>
<p>###去除缓存<br>在etcd目录下在终端执行make clean，清除缓存。</p>
<h3 id="下载安装-etcd"><a href="#下载安装-etcd" class="headerlink" title="下载安装 etcd"></a>下载安装 etcd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p $GOPATH/src/github.com/coreos</span><br><span class="line">$ cd coreos</span><br><span class="line">$ git clone https://github.com/coreos/etcd.git</span><br><span class="line">$ cd etcd</span><br><span class="line">$ ./build</span><br></pre></td></tr></table></figure>
<p>###终端运行export ETCDCTL_API=3</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=token-01</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=machine-1</span><br><span class="line">NAME_2=machine-2</span><br><span class="line">NAME_3=machine-3</span><br><span class="line">HOST_1=192.168.1.126</span><br><span class="line">HOST_2=192.168.1.119</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380</span><br></pre></td></tr></table></figure>
<p><strong>machine 1</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 1</span><br><span class="line">THIS_NAME=$&#123;NAME_1&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_1&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p><strong>machine 2</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 2</span><br><span class="line">THIS_NAME=$&#123;NAME_2&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_2&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p><strong>machine 3</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 3</span><br><span class="line">THIS_NAME=$&#123;NAME_3&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_3&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p>检测服务器运行是否正常,开启新的终端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line">export ETCDCTL_API=3</span><br><span class="line">HOST_1=192.168.1.126</span><br><span class="line">HOST_2=192.168.1.119</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS member list</span><br></pre></td></tr></table></figure>
<h3 id="存储数据-1"><a href="#存储数据-1" class="headerlink" title="存储数据"></a>存储数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World&quot;//!号不能存</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS get foo</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo</span><br></pre></td></tr></table></figure>
<h3 id="根据前缀查询-1"><a href="#根据前缀查询-1" class="headerlink" title="根据前缀查询"></a>根据前缀查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put web1 value1</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put web2 value2</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put web3 value3</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS get web --prefix</span><br><span class="line"></span><br><span class="line">web1</span><br><span class="line">value1</span><br><span class="line">web2</span><br><span class="line">value2</span><br><span class="line">web3</span><br><span class="line">value3</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put key myvalue</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS del key</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put k1 value1</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put k2 value2</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS del k --prefix</span><br></pre></td></tr></table></figure>
<h3 id="事务写入-1"><a href="#事务写入-1" class="headerlink" title="事务写入"></a>事务写入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</span><br><span class="line"></span><br><span class="line">compares:</span><br><span class="line">// 输入以下内容，输入结束按 两次回车</span><br><span class="line">value(&quot;user1&quot;) = &quot;bad&quot;      </span><br><span class="line"></span><br><span class="line">//如果 user1 = bad，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != bad，则执行 put user1 good</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 good</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 success</span><br><span class="line">SUCCESS</span><br><span class="line"></span><br><span class="line">user1</span><br><span class="line">bad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</span><br><span class="line">compares:</span><br><span class="line">value(&quot;user1&quot;) = &quot;111&quot;  </span><br><span class="line"></span><br><span class="line">// 如果 user1 = 111，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != 111，则执行 put user1 2222</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 2222</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 failure</span><br><span class="line">FAILURE</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS get user1</span><br><span class="line">user1</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>
<h3 id="watch-1"><a href="#watch-1" class="headerlink" title="watch"></a>watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS watch stock1</span><br><span class="line"></span><br><span class="line">// 新打开终端</span><br><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line">export ETCDCTL_API=3</span><br><span class="line">HOST_1=192.168.1.126</span><br><span class="line">HOST_2=192.168.1.119</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock1 1000</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS watch stock --prefix</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock1 10</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock2 20</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Unmarshal及json标签和marshal"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/28/Unmarshal及json标签和marshal/" class="article-date">
	  <time datetime="2018-05-28T10:11:47.383Z" itemprop="datePublished">五月 28, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Unmarshal及json标签和marshal"><a href="#Unmarshal及json标签和marshal" class="headerlink" title="Unmarshal及json标签和marshal"></a>Unmarshal及json标签和marshal</h1><p>##Unmarshal<br>package main</p>
<p>import (<br>    “encoding/json”<br>    “fmt”<br>)</p>
<p>type person struct {<br>    First string<br>    Last  string<br>    Age   int <code>json:&quot;ageNUM&quot;</code>//标签<br>}</p>
<p>func main() {<br>    var p1 person<br>    //p1 =person{“zhang”,”heng”,20}<br>    fmt.Println(p1.First)<br>    fmt.Println(p1.Last)<br>    fmt.Println(p1.Age)</p>
<pre><code>bs := []byte(`{&quot;First&quot;:&quot;James&quot;, &quot;Last&quot;:&quot;Bond&quot;, &quot;ageNUM&quot;:20}`)
json.Unmarshal(bs, &amp;p1)//自己认为是把bs数组映射到p1中，专业解析：unmarshal反序列化，也就是说从前端拿到json字符串，
//然后转成字节数组，映射到p1结构体里。输出

fmt.Println(&quot;--------------&quot;)
fmt.Println(p1.First)
fmt.Println(p1.Last)
fmt.Println(p1.Age)
fmt.Printf(&quot;%T \n&quot;, p1)
</code></pre><p>}</p>
<p>##json标签及marshal<br>package main</p>
<p>import (<br>    “encoding/json”<br>    “fmt”<br>)</p>
<p>type person struct {<br>    First string//因为是共有标签所以首字母必须大写，才能被调用，但是后缀跟上json，那么就大小写无所谓，因为标签不再是结构体的key，而是对应json的标签<br>    Last  string <code>json:&quot;-&quot;</code>//代表忽略<br>    Age   int    <code>json:&quot;wisdom score&quot;</code>//给他添加标签<br>}</p>
<p>func main() {<br>    p1 := person{“James”, “Bond”, 20}<br>    bs, _ := json.Marshal(p1)<br>    fmt.Println(string(bs))<br>}<br>输出{“First”:”James”,”wisdom score”:20}</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-go语言下的http包"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/26/go语言下的http包/" class="article-date">
	  <time datetime="2018-05-26T08:15:35.989Z" itemprop="datePublished">五月 26, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>#go语言下的http包<br>go web hello world:</p>
<p>package main</p>
<p>import (<br>    “io”<br>    “net/http”<br>)</p>
<p>func main() {<br>    http.HandleFunc(“/“, sayhello)<br>    http.ListenAndServe(“:8080”, nil)<br>}</p>
<p>func sayhello(w http.ResponseWriter, r *http.Request) {<br>    io.WriteString(w, “hello world”)<br>}</p>
<p>首先注册一个sayhello函数给“/”，当浏览器浏览“/”的时候，会调用sayhello函数<br>其次开始监听和服务，“:8080”表示本机所有的ip地址的8080<br>查询ListenAndServe的文档可知，第2个参数是一个Hander<br>Hander是啥呢，它是一个接口。这个接口很简单，只要某个struct有ServeHTTP(http.ResponseWriter, *http.Request)这个方法，那这个struct就自动实现了Hander接口<br>那就ServeHTTP方法，他需要2个参数，一个是http.ResponseWriter，另一个是http.Request<br>往http.ResponseWriter写入什么内容，浏览器的网页源码就是什么内容<br>http.Request里面是封装了，浏览器发过来的请求（包含路径、浏览器类型等等）</p>
<p><a href="https://gowalker.org/net/http#ListenAndServe" target="_blank" rel="noopener">https://gowalker.org/net/http#ListenAndServe</a></p>
<p>认识http.ResponseWriter</p>
<p>把 “网页未找到”的代码改一下，让大家认识一下http.ResponseWriter<br>看清楚了，ServeHTTP方法是自己写的啊，自己去实现</p>
<p>package main</p>
<p>import (<br>    “io”<br>    “net/http”<br>)</p>
<p>type a struct{}</p>
<p>func (<em>a) ServeHTTP(w http.ResponseWriter, r </em>http.Request) {<br>    io.WriteString(w, “hello world version 1.”)<br>}</p>
<p>func main() {<br>    http.ListenAndServe(“:8080”, &amp;a{})//第2个参数需要实现Hander的struct，a满足<br>}<br>访问localhost:8080的话，可以看到“hello world version 1.”<br>访问localhost:8080/abc的话，可以看到“hello world version 1.”<br>访问localhost:8080/123的话，可以看到“hello world version 1.”<br>事实上访问任何路径都是“hello world version 1.”</p>
<p>哦，原来是这样，当http.ListenAndServe(“:8080”, &amp;a{})后，开始等待有访问请求<br>一旦有访问请求过来，http包帮我们处理了一系列动作后，最后他会去调用a的ServeHTTP这个方法，并把自己已经处理好的http.ResponseWriter, <em>http.Request传进去<br>而a的ServeHTTP这个方法，拿到</em>http.ResponseWriter后，并往里面写东西，客户端的网页就显示出来了</p>
<p>认识*http.Request</p>
<p>现在把上面的代码再改一下，让大家认识一下*http.Request</p>
<p>package main</p>
<p>import (<br>    “io”<br>    “net/http”<br>)</p>
<p>type a struct{}</p>
<p>func (<em>a) ServeHTTP(w http.ResponseWriter, r </em>http.Request) {<br>    path := r.URL.String() //获得访问的路径<br>    io.WriteString(w, path)<br>}</p>
<p>func main() {<br>    http.ListenAndServe(“:8080”, &amp;a{})//第2个参数需要实现Hander接口的struct，a满足<br>}<br>现在<br>访问localhost:8080的话，可以看到“/”<br>访问localhost:8080/abc的话，可以看到“/abc”<br>访问localhost:8080/123的话，可以看到“/123”</p>
<p>最傻的网站</p>
<p>如果再加上一些判断的话，一个最傻的可运行网站就出来了，如下</p>
<p>package main</p>
<p>import (<br>    “io”<br>    “net/http”<br>)</p>
<p>type a struct{}</p>
<p>func (<em>a) ServeHTTP(w http.ResponseWriter, r </em>http.Request) {<br>    path := r.URL.String()<br>    switch path {<br>    case “/“:<br>        io.WriteString(w, “</p><h1>root</h1><a href="\"abc\"">abc</a>“)<br>    case “/abc”:<br>        io.WriteString(w, “<h1>abc</h1><a href="\"/\"">root</a>“)<br>    }<br>}<p></p>
<p>func main() {<br>    http.ListenAndServe(“:8080”, &amp;a{})//第2个参数需要实现Hander接口的struct，a满足<br>}<br>运行后，可以看出，一个case就是一个页面<br>如果一个网站有上百个页面，那是否要上百个case？<br>很不幸，是的<br>那管理起来岂不是要累死？<br>要累死，不过，还好有ServeMux</p>
<p>用ServeMux拯救最傻的网站</p>
<p>现在来介绍ServeMux</p>
<p>ServeMux大致作用是，他有一张map表，map里的key记录的是r.URL.String()，而value记录的是一个方法，这个方法和ServeHTTP是一样的，这个方法有一个别名，叫HandlerFunc<br>ServeMux还有一个方法名字是Handle，他是用来注册HandlerFunc 的<br>ServeMux还有另一个方法名字是ServeHTTP，这样ServeMux是实现Handler接口的，否者无法当http.ListenAndServe的第二个参数传输</p>
<p>package main</p>
<p>import (<br>    “net/http”<br>    “io”<br>)</p>
<p>type b struct{}</p>
<p>func (<em>b) ServeHTTP(w http.ResponseWriter, r </em>http.Request) {<br>    io.WriteString(w, “hello”)<br>}<br>func main() {<br>    mux := http.NewServeMux()<br>    mux.Handle(“/h”, &amp;b{})<br>    http.ListenAndServe(“:8080”, mux)<br>}</p>
<p>解释一下<br>mux := http.NewServeMux():新建一个ServeMux。<br>mux.Handle(“/“, &amp;b{}):注册路由，把”/“注册给b这个实现Handler接口的struct，注册到map表中。<br>http.ListenAndServe(“:8080”, mux)第二个参数是mux。<br>运行时，因为第二个参数是mux，所以http会调用mux的ServeHTTP方法。<br>ServeHTTP方法执行时，会检查map表（表里有一条数据，key是“/h”，value是&amp;b{}的ServeHTTP方法）<br>如果用户访问/h的话，mux因为匹配上了，mux的ServeHTTP方法会去调用&amp;b{}的 ServeHTTP方法，从而打印hello<br>如果用户访问/abc的话，mux因为没有匹配上，从而打印404 page not found</p>
<p>ServeMux就是个二传手！</p>
<p>ServeMux的HandleFunc方法</p>
<p>发现了没有，b这个struct仅仅是为了装一个ServeHTTP而存在，所以能否跳过b呢，ServeMux说：可以<br>mux.HandleFunc是用来注册func到map表中的</p>
<p>package main</p>
<p>import (<br>    “net/http”<br>    “io”<br>)</p>
<p>func main() {<br>    mux := http.NewServeMux()<br>    mux.HandleFunc(“/h”, func(w http.ResponseWriter, r <em>http.Request) {<br>        io.WriteString(w, “hello”)<br>    })<br>    mux.HandleFunc(“/bye”, func(w http.ResponseWriter, r </em>http.Request) {<br>        io.WriteString(w, “byebye”)<br>    })<br>    mux.HandleFunc(“/hello”, sayhello)<br>    http.ListenAndServe(“:8080”, mux)<br>}</p>
<p>func sayhello(w http.ResponseWriter, r *http.Request) {<br>    io.WriteString(w, “hello world”)<br>}</p>
<p>ServeMux的白话解释</p>
<p>如果把http服务想象成一个公司的话<br>没有ServeMux的话，就像这个公司只有1个人–老板，什么事情都是由老板来做（自己写switch）<br>包括做业务（“/sales”），做帐（“/account”），内勤（“/management”），扫地（“/cleaner”）</p>
<p>后来老板招了4个人，负责上面的4件事情，那老板要做的就是根据情况转发就是了，比如做业务的事情，自己就不用去跑客户了，交给销售经理去做，并给销售经理一些资源（包括客户名称地址什么的）<br>上面代码里的type b struct{}就是个销售经理，资源就是w http.ResponseWriter, r *http.Request，老板要工作的就是ServeMux要做的工作</p>
<p>以上的代码就做了一层转发，老板给销售经理事情后，销售经理去跑客户了，也就结束了</p>
<p>实际生活中，销售经理不会自己去跑客户的，他也会把接来的活转给更下面的业务员<br>那时，销售经理自己也变成一个ServeMux了</p>
<p>所以为了可以ServeMux套ServeMux，需要改造一下ServeMux的ServeHTTP，改完后可以嵌套无限层，把要做的事情不断的细化<br>到最后要真正做事情的人，只需要关心自己要做的事情就可以了，自己做自己份内的事，一个大公司就运作起来了</p>
<p>回到开头</p>
<p>回到开头，有让大家先忘掉http.HandleFunc(“/“, sayhello)<br>请先忘记引子里的http.HandleFunc(“/“, sayhello)，这个要到很后面才提到</p>
<p>当http.ListenAndServe(“:8080”, nil)的第2个参数是nil时<br>http内部会自己建立一个叫DefaultServeMux的ServeMux，因为这个ServeMux是http自己维护的，如果要向这个ServeMux注册的话，就要用http.HandleFunc这个方法啦，现在看很简单吧</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-POW共识算法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/21/POW共识算法/" class="article-date">
	  <time datetime="2018-05-21T01:05:40.365Z" itemprop="datePublished">五月 21, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="POW共识算法"><a href="#POW共识算法" class="headerlink" title="POW共识算法"></a>POW共识算法</h1><p>以太坊和比特币运用该算法，为比特币提供挖矿的过程。<br>区块包括：第几块区块（高度）；时间戳；当前hash，上一个hash，数据data，nonce值（随机值）；diff难度系数。<br>第一个区块叫创世区块，每10分钟产生一个区块。<br>通过pow共识进行挖矿，产生满足难度系数的新区块。<br>代码如下：<br>package main</p>
<p>import (<br>    “time”<br>    “strconv”<br>    “crypto/sha256”<br>    “encoding/hex”<br>    “fmt”<br>    “strings”<br>)</p>
<p>//通过代码完成pow挖矿<br>//创建区块</p>
<p>type Block struct {<br>    Index int//区块高度<br>    TimeStamp string //时间戳<br>    Diff int//当前网络的难度系数<br>    PreHash string//上一个区块的hash值<br>    HashCode string//当前区块的hash值<br>    Nonce int//随机数<br>    Data string//存交易信息<br>}<br>//创建创世区块，也就是第一个区块<br>func GenerateFirstBlock(data string)Block  {<br>    var firstBlock Block<br>    firstBlock.Index=1<br>    firstBlock.TimeStamp=time.Now().String()<br>    firstBlock.Diff=4<br>    firstBlock.Nonce=0<br>    firstBlock.Data=data<br>    firstBlock.HashCode=GenreateBlockHashValue(firstBlock)<br>    return firstBlock<br>}<br>//生成区块的hash值<br>func GenreateBlockHashValue(block Block)string  {<br>    //按照比特的写法，将区块的所有属性拼接后做hash运算<br>    var hashdata = strconv.Itoa(block.Index)+block.TimeStamp+strconv.Itoa(block.Diff)+<br>        strconv.Itoa(block.Nonce)+block.Data<br>        //hash算法<br>        var sha=sha256.New()<br>        sha.Write([]byte(hashdata))<br>        hashed:=sha.Sum(nil)</p>
<pre><code>return hex.EncodeToString(hashed)//将16进制转换成字符串
</code></pre><p>}</p>
<p>//产生新区块<br>func GenerateNextBlock(data string,oldBlock Block)Block  {<br>    var newBlock Block<br>    newBlock.Data=data<br>    newBlock.Diff=6<br>    newBlock.TimeStamp=time.Now().String()<br>    //暂时设置为0，nonce值应该是有矿工操作处理<br>    newBlock.Nonce=0<br>    newBlock.PreHash=oldBlock.HashCode<br>    newBlock.Index=2<br>    //应该填写POW成功后，带有0000的那个哈希值<br>    newBlock.HashCode=pow(newBlock.Diff,&amp;newBlock)<br>    return newBlock<br>}<br>//挖矿proof of work工作量证明算法<br>func pow(diff int,block <em>Block)string  {<br>    for {<br>        hash := GenreateBlockHashValue(</em>block)<br>        fmt.Println(hash)<br>        if strings.HasPrefix(hash, strings.Repeat(“0”, diff)) {<br>                fmt.Println(“挖矿成功”)<br>                return hash<br>        }else {<br>            block.Nonce++<br>        }<br>    }<br>}<br>func main()  {<br>    var first =GenerateFirstBlock(“创世区块”)<br>    fmt.Println(first)<br>    //需要通过挖矿操作第二区块<br>    GenerateNextBlock(“第二区块”,first)</p>
<p>}</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-对称加密和非对称加密"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/19/对称加密和非对称加密/" class="article-date">
	  <time datetime="2018-05-19T11:48:23.164Z" itemprop="datePublished">五月 19, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h1><p>##DES加密解密<br>加密过程：明文64位-&gt;初始置换IP-&gt;16轮加密变换-&gt;逆初始置换IP-1-&gt;密文<br>1.首先对字符串的明文转成字节数组，按照密钥长度进行补码，补码过程：<br>func PKCS5Padding(ciphertext []byte,blockSize int) []byte {<br>    padding:=blockSize-len(ciphertext)%blockSize<br>    fmt.Println(blockSize)<br>    padtext := bytes.Repeat([]byte{byte(padding)},padding)//补码过程<br>    return append(ciphertext,padtext…)<br>}<br>2.把补码完的明文按blockSize的倍数分成n组。每组有64位，也就是8个字节。每组明文按照初始IP置换表的规则进行替换：如<br>图为初始置换IP表 <img src="media/15267305031577/15267942943081.jpg" alt=""></p>
<p>这里的初始IP置换表的意思为把64位明文按照表中的规则替换，比如第一行，把64位明文的第1位换为其58位，第2位换为50位，第3位换位42位…这表仔细观察有一定的规律，比如我们从右到左一列一列的分别读前4行，后4行。是不是就是2 4 6 8 10 12…和1 3 5 7 9 11…<br>3.16轮加密变换<br>把上边置换完每组明文分为LO和RO各32位。　<br>密钥先做一次置换，再做16次包含循环左移和置换的操作组合，每次都产生一个子密钥Ki。每一轮的置换操作都完全相同，但由于循环左移而使得每个子密钥不同每一轮的置换操作都完全相同，但由于循环左移而使得每个子密钥不同<img src="media/15267305031577/15267946625132.jpg" alt=""><br>上图所示：第一次运算函数f(RO,K1)的结果与LO异或，结果就是下一轮的R1，L1是上一轮的RO，接下来的一样方法，最后得到R16和L16进行逆初试置换IP-1（同始置换IP-1）得到密文。<br>代码如下：<br>package main</p>
<p>import (<br>    “crypto/cipher”//密码<br>    “crypto/des”<br>    “encoding/base64”//将对象转换成字符串<br>    “fmt”<br>    “bytes”<br>)<br>//DES 3DES AES<br>//用同一个密钥加密和解密</p>
<p>//DES加密的方法<br>func MyDesEncrypt(origData,key[]byte)  {<br>    block,_:=des.NewCipher(key)</p>
<pre><code>origData =PKCS5Padding(origData,des.BlockSize)
//设置加密方式
blockMode:=cipher.NewCBCEncrypter(block,key)
//创建明文长度的字节数组
crypted :=make([]byte,len(origData))
//加密明文
blockMode.CryptBlocks(crypted,origData)
//将字节数组转换成字符串
fmt.Println(base64.StdEncoding.EncodeToString(crypted))
</code></pre><p>}<br>//明文补码<br>func PKCS5Padding(ciphertext []byte,blockSize int) []byte {<br>    padding:=blockSize-len(ciphertext)%blockSize<br>    fmt.Println(blockSize)<br>    padtext := bytes.Repeat([]byte{byte(padding)},padding)//补码过程</p>
<pre><code>return append(ciphertext,padtext...)
</code></pre><p>}<br>//实现去补码<br>func PKCS5UnPadding(origData []byte)[]byte  {<br>    length:=len(origData)<br>    unpadding:=int(origData[length-1])<br>    return origData[:(length-unpadding)]<br>}<br>//DES解密方法<br>func MyDESDecrypt(data string,key []byte)  {<br>    //将字符串转换成字节数组<br>     crypted,<em>:=base64.StdEncoding.DecodeString(data)<br>     //将字节密钥转换成block块<br>     block,</em>:=des.NewCipher(key)<br>     //设置解密方式<br>     blockMode:=cipher.NewCBCDecrypter(block,key)<br>     //创建秘文大小的数组变量<br>     origData:=make([]byte,len(crypted))<br>     //解密秘文到数组origData中<br>     blockMode.CryptBlocks(origData,crypted)<br>     origData=PKCS5UnPadding(origData)<br>     fmt.Println(origData)<br>     fmt.Println(string((origData)))<br>}<br>func main()  {<br>    fmt.Println(“hello world”)<br>    //声明一个密钥,利用此密钥实现明文的加密和解密<br>    key :=[]byte(“12345698”)<br>    MyDesEncrypt([]byte(“hello world “ ),key)<br>    MyDESDecrypt(“NIJWb9F1DO11q08fSnB/HA==”,key)<br>}<br>CBC加密步骤如下：</p>
<ol>
<li>首先将数据按照8个字节一组进行分组得到D1D2……Dn（若数据不是8的整数倍，用指定的PADDING数据补位）</li>
<li>第一组数据D1与初始化向量I异或后的结果进行DES加密得到第一组密文C1（初始化向量I为全零）</li>
<li>第二组数据D2与第一组的加密结果C1异或以后的结果进行DES加密，得到第二组密文C2</li>
<li>之后的数据以此类推，得到Cn</li>
<li>按顺序连为C1C2C3……Cn即为加密结果。</li>
</ol>
<p>DES ECB（电子密本方式）其实非常简单，就是将数据按照8个字节一段进行DES加密或解密得到一段段的8个字节的密文或者明文，最后一段不足8个字节（一般补0或者F），按照需求补足8个字节进行计算（并行计算），之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。</p>
<p>##DSA签名与验证<br>首先了解下bigInt和int的差别：<br>bigint 带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。<br>int  普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。</p>
<p>DSA（Digital Signature Algorithm，数字签名算法，用作数字签名标准的一部分），它是另一种公开密钥算法，它不能用作加密，只用作数字签名。DSA使用公开密钥，为接受者验证数据的完整性和数据发送者的身份。它也可用于由第三方去确定签名和所签数据的真实性。DSA算法的安全性基于解离散对数的困难性，这类签字标准具有较大的兼容性和适用性，成为网络安全体系的基本构件之一。<br>p是L位长的素数，其中L从512到1024且是64的倍数。<br>q是160位长且与p-1互素的因子，其中h是小于p-1并且满足 大于1的任意数。</p>
<p>x是小于q的数。</p>
<p>另外，算法使用一个单向散列函数H（m）。标准指定了安全散列算法（SHA）。三个参数p，q和g是公开的，且可以被网络中所有的用户公有。私人密钥是x，公开密钥是y。</p>
<p>对消息m签名时：</p>
<p>（1） 发送者产生一个小于q的随机数k。</p>
<p>（2） 发送者产生：</p>
<p>r和s就是发送者的签名，发送者将它们发送给接受者。</p>
<p>（3） 接受者通过计算来验证签名：</p>
<p>如果v=r，则签名有效。</p>
<p>DSA签名：</p>
<p>公开密钥：</p>
<p>p 512位到1024位的素数</p>
<p>q 160位长，并与p-1互素的因子</p>
<p>其中h是小于p-1并且满足 大于1的任意数。</p>
<p>私人密钥：</p>
<p>x小于q</p>
<p>签名：</p>
<p>k选取小于q的随机数</p>
<p>验证：</p>
<p>如果v=r，则签名被验证。<br>代码如下：<br>package main</p>
<p>import (<br>    “crypto/dsa”<br>    “crypto/rand”<br>    “fmt”</p>
<p>)<br>//作用1 确保传递数据的完整性 2 确保数据的来源<br>func main()  {<br>    //DSA专业做签名和验签<br>    var param dsa.Parameters<br>    dsa.GenerateParameters(&amp;param,rand.Reader,dsa.L1024N160)<br>    //生成私钥<br>    var priv dsa.PrivateKey<br>    priv.Parameters=param<br>    dsa.GenerateKey(&amp;priv,rand.Reader)</p>
<pre><code>//通过私钥生成公钥
pub:=priv.PublicKey
fmt.Println(pub)


message:=[]byte(&quot;hello world&quot;)
//r,s是两个整数
r,s,_:=dsa.Sign(rand.Reader,&amp;priv,message)

//利用公钥验签
b:= dsa.Verify(&amp;pub,message,r,s)
if b==true{
    fmt.Println(&quot;验签成功&quot;)
}else {
    fmt.Println(&quot;验证失败&quot;)
}
</code></pre><p>}</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-012+公钥加密"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/17/012+公钥加密/" class="article-date">
	  <time datetime="2018-05-17T07:08:48.764Z" itemprop="datePublished">五月 17, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="012-公钥加密"><a href="#012-公钥加密" class="headerlink" title="012 公钥加密"></a>012 公钥加密</h1><p>公钥密码又称为非对称密码，拥有公钥密码的用户分别拥有加密密钥和解密密钥。通过加密密钥不能得到解密密钥。并且加密密钥是公开的。</p>
<h2 id="什么是密钥配送问题"><a href="#什么是密钥配送问题" class="headerlink" title="什么是密钥配送问题"></a>什么是密钥配送问题</h2><p>在现实世界中使用对称密码时，我们一定会遇到密钥配送问题( key distribution problem)。</p>
<p>假如 A 给 B 写了一封情书，并使用对称加密，如果不讲加密密钥发送给B，B是无法查看情书的，如果将密钥和情书一起发送给B，就容易被攻击者截获。</p>
<p><strong>密钥必须要发送，但又不能发送</strong>，这就是对称密码的密钥配送问题。</p>
<p>解决密钥配送问题的方法：</p>
<ul>
<li>通过事先共享密钥来解决</li>
<li>通过密钥分配中心来解决</li>
<li>通过Diffie-Hellman密钥交换来解决</li>
<li>通过公钥密码来解决</li>
</ul>
<h3 id="通过事先共享密钥来解决"><a href="#通过事先共享密钥来解决" class="headerlink" title="通过事先共享密钥来解决"></a>通过事先共享密钥来解决</h3><p>密钥配送问题最简单的一种解决方法，就是事先用安全的方式将密钥交给对方，这称为密钥的事先共享。 事先共享的局限性:</p>
<ul>
<li>需要一种安全的方式将密钥交给对方。</li>
<li>即便能够实现事先共享密钥，但在人数很多的情况下，通信所需要的密钥数量也会增大。</li>
</ul>
<h3 id="通过密钥分配中心来解决"><a href="#通过密钥分配中心来解决" class="headerlink" title="通过密钥分配中心来解决"></a>通过密钥分配中心来解决</h3><p>如果所有参与加密通信的人都需要事先共享密钥，则密钥的数量会变得巨大，这样额情况下就可以使用密钥分配中心（Key Distribution Center，KDC）来解决密钥配送问题。当需要进行加密通信时，密钥分配中心会生成一个通信密钥，每个人只要和密钥分配中心事先共享密钥就可以了。有多少个人进行通信分配中心就保存了多少密钥。</p>
<p>局限性：</p>
<ul>
<li><p>随着通信人数的增加，密钥分配中心的负荷也会随之增加。如果密钥分配中心计算机发生故障，所有的加密通信就会瘫痪。</p>
</li>
<li><p>如果主动攻击者入侵了密钥分配中心计算机，并盗取了密钥数据库，所有人的加密通信都会被破译。</p>
</li>
</ul>
<h3 id="通过Diffie-Hellman密钥交换来解决"><a href="#通过Diffie-Hellman密钥交换来解决" class="headerlink" title="通过Diffie-Hellman密钥交换来解决"></a>通过Diffie-Hellman密钥交换来解决</h3><p>在Diffie-Hellman密钥交换中，进行加密通信的双方需要交换一些信息，而这些信息即便被窃听者听到也没有关系。<br>根据所交换的信息，双方可以各自生成相同的密钥，而窃听者却无法生成相同的密钥。窃听者虽然能够窃听到双方交换的信息但却无法根据这些信息生成和双方相同的密钥。</p>
<h3 id="通过公钥密码来解决"><a href="#通过公钥密码来解决" class="headerlink" title="通过公钥密码来解决"></a>通过公钥密码来解决</h3><h2 id="什么是公钥密码"><a href="#什么是公钥密码" class="headerlink" title="什么是公钥密码"></a>什么是公钥密码</h2><p>公钥密码( public-key cryptography)，又称为非对称密码，密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。</p>
<p>加密密钥和解密密钥的区别：</p>
<ul>
<li>发送者只需要加密密钥</li>
<li>接收者只需要解密密钥</li>
<li>解密密钥不可以被窃听者获取</li>
<li>加密密钥被窃听者获取也没问题</li>
</ul>
<p>解密密钥从一开始就是由接收者自己保管的，因此只要将加密密钥发给发送者就可以解决<strong>密钥配送问题</strong>了，而根本不需要配送解密密钥。</p>
<h2 id="公钥通信的流程"><a href="#公钥通信的流程" class="headerlink" title="公钥通信的流程"></a>公钥通信的流程</h2><p>我们还是假设Alice要给Bob发送一条消息，Alice是发送者，Bob 是接收者，而这次窃听者Eve依然能够窃听到他们之间<br>的通信内容。</p>
<p>在公钥密码通信中，通信过程是由接收者Bob来启动的。</p>
<ol>
<li><p>Bob生成一个包含公钥和私钥的密钥对。私钥由Bob自行妥善保管。</p>
</li>
<li><p>Bob 将自己的公钥发送给Alice。</p>
<p> Bob的公钥被窃听者Eve截获也没关系。<br> 将公钥发送给Alice,表示Bob请Alice用这个公钥对消息进行加密并发送给他。</p>
</li>
<li><p>Alice用Bob的公钥对消息进行加密。</p>
<p> 加密后的消息只有用Bob的私钥才能够解密。虽然Alice拥有Bob 的公钥，但用Bob的公钥是无法对密文进行解密的。</p>
</li>
<li><p>Alice将密文发送给Bob。</p>
<p> 密文被窃听者Eve截获也没关系。Eve可能拥有Bob的公钥，但是用Bob的公钥是无法进行解密的。</p>
</li>
<li><p>Bob用自己的私钥对密文进行解密</p>
</li>
</ol>
<p>公钥通信的流程图：</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180117-065945.png" alt=""></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Golang细节汇总"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/05/02/Golang细节汇总/">go语言细节及重点汇总</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2018/05/02/Golang细节汇总/" class="article-date">
	  <time datetime="2018-05-02T13:53:12.506Z" itemprop="datePublished">五月 2, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Golang细节汇总"><a href="#Golang细节汇总" class="headerlink" title="Golang细节汇总"></a>Golang细节汇总</h1><h2 id="mac-goland-安装"><a href="#mac-goland-安装" class="headerlink" title="mac goland 安装"></a>mac goland 安装</h2><p>mac系统安装并配置</p>
<p>安装</p>
<p>双击pkg包，顺着指引，即可安装成功。 </p>
<p>在命令行输入 go version，获取到go的版本号，则代表安装成功。</p>
<p>配置环境变量</p>
<p>1、打开终端输入cd ~进入用户主目录; </p>
<p>2、输入ls -all命令查看是否存在.bash_profile; </p>
<p>3、存在既使用vim .bash_profile 打开文件; </p>
<p>4、输入 i 进入vim编辑模式； </p>
<p>5、输入下面代码， </p>
<p>其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。</p>
<p>export GOPATH=/Users/ruby/go</p>
<p>export GOBIN=$GOPATH/bin</p>
<p>export PATH=$PATH:$GOBIN</p>
<p>6、点击ESC，并输入 :wq 保存并退出编辑。可输入vim .bash_profile 查看是否保存成功。</p>
<p>7、输入source ~/.bash_profile 完成对golang环境变量的配置，配置成功没有提示。 </p>
<p>8、输入go env 查看配置结果</p>
<h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><p>正数的原码，反码，补码都是二进制的本身（第一位表示符号位）</p>
<p>负数的第一位为1，表示负数</p>
<p>负数的反码是在其原码的基础上，符号位不变，其余各位按位取反</p>
<p>负数的补码是反码+1</p>
<p>计算机存储数值都是二进制，而且是以补码的形式存储。为了解决负数问题</p>
<h2 id="switch-fallthrough用法"><a href="#switch-fallthrough用法" class="headerlink" title="switch fallthrough用法"></a>switch fallthrough用法</h2><p><1> 如需贯通后续的case，就添加fallthrough</1></p>
<p>如：</p>
<pre><code>switch x := 5; x {
default:
    fmt.Println(x)
case 5:
    x += 10
    fmt.Println(x)
    fallthrough
case 6:
    x += 20
    fmt.Println(x)

}
</code></pre><p>输出</p>
<p>15<br>35</p>
<p><2>case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。</2></p>
<pre><code>func main(){
num := 75
switch { // expression is omitted
case num &gt;= 0 &amp;&amp; num &lt;= 50:
    fmt.Println(&quot;num is greater than 0 and less than 50&quot;)
case num &gt;= 51 &amp;&amp; num &lt;= 100:
    fmt.Println(&quot;num is greater than 51 and less than 100&quot;)
case num &gt;= 101:
    fmt.Println(&quot;num is greater than 100&quot;)
      }
}
</code></pre><p><3>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</3></p>
<p>语法以及举证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">" x 的类型 :%T"</span>,i)                </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">"x 是 int 型"</span>)                       </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 float64 型"</span>)           </span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">float64</span>:</span></span><br><span class="line">         fmt.Printf("x 是 func(int) 型")                      </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 bool 或 string 型"</span> )       </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"未知型"</span>)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 </p>
</li>
<li><p>否则：</p>
<p>如果有default子句，则执行该语句。</p>
<p>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>
</li>
</ul>
<h2 id="slice-array切片和数组的创建"><a href="#slice-array切片和数组的创建" class="headerlink" title="slice,array切片和数组的创建"></a>slice,array切片和数组的创建</h2><p>1.数组 ：值传递</p>
<p>​    概念：存储一组相同的数据类型的数据结构。</p>
<p>​    特点：数据结构：内存上是连续空间。</p>
<p>​    存储数据特点：有序，可以重复。</p>
<p>​                数据类型一致。</p>
<p>​                定长：数组一旦创建长度不能更改，但是可以更改存储的数据。</p>
<p>​    语法：</p>
<p>   A：数组的创建</p>
<p>   var variable_name [SIZE] variable_type</p>
<p>​     var a [4] int</p>
<p>​     var b = [4]int{}</p>
<p>​      var c = [4] int {1,2,3,4}</p>
<p>​     var d = [4]int{1,2}//后边补零</p>
<p>​      e := [4]int{index:value}</p>
<p>​      f:=[…] int{}</p>
<p>   B：数组的访问</p>
<p>​      主要通过下标：index，取值范围是：从0开始，到长度减1。</p>
<p>​      index（下标）：,数据在数组中的位置。从0开始，到长度减1。否则越界异常。</p>
<p>​      赋值：数组名[index] = value（数据）</p>
<p>​      取值：数组名[index]</p>
<p>遍历数组：依次获取数组中的数据</p>
<p>​            range 数组名：index，value</p>
<p>​    数组的类型：值类型：传递该数据的时候，传递数据的副本(备份，复制)</p>
<p>​            arr1:=[5] int {1,1,1,1,1}</p>
<p>​            arr2 = arr1//将arr1的数据拷贝一份，值赋值给arr2。</p>
<p>​                        //如果在把arr1的值赋值给arr1之后，更改了arr1的内容，对于arr2没</p>
<p>​                            有影响。因为是值类型，传递的是备份数据。        </p>
<p>​    循环操作数组：</p>
<p>​            for i:=0;i&lt;len(arr);i++{</p>
<p>​                arr[i] </p>
<p>​            }</p>
<p>​            range–&gt;数组：将数组的下标和对应的数值</p>
<p>​            for index,value := range arr{</p>
<p>​                index：下标</p>
<p>​                value：数据</p>
<p>​            }</p>
<p>​    数据类型：数组的类型：[size]type，</p>
<p>​    数组的排序：数组中的数据，按照升序或降序排列。</p>
<p>​    冒泡排序：思路：每次比较相邻的两个数，如果前一个数大于后一个数，交换。排n轮：    </p>
<p>​                长度-1    </p>
<p>a := [5] int {30,31,18,17,15}</p>
<p>for i:=1;i&lt;len(a);i++{</p>
<p> for j:=0;j&lt;len(a)-i;j++{</p>
<p>​     if a[j]&gt;a[j+1]{</p>
<p>​        a[j] ,a[j+1]=a[j+1],a[j]</p>
<p>​      }</p>
<p>   }</p>
<p>   fmt.Println(a)</p>
<p>​    多维数组：二维数组：一维的一维</p>
<p>​            一维数组，直接存储数据本身</p>
<p>​            二维数组，存储的是一维数组</p>
<p>语法：       c := [3][4] int{</p>
<p>​                     {1,2,3,4},</p>
<p>​                     {5,6,7,8},</p>
<p>​                  {9,10,11,12}}</p>
<p>len(b)–&gt;二维数组的长度：存储了几个一维数组</p>
<p>len(b[0])–&gt;第一个一维数组的长度</p>
<p>b[0][0]–&gt;第一个一维数组中，第一个数据</p>
<p>len(),cap()，数组的长度和容量一致的。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9c0a3e77aee595f07194cb7cce079811/xmlnote/0FC740ACE2114E5DA5678F848911BCD6/32BA34A8FF704B5E95B9C9A0C93CB942/418" alt="img"></p>
<p>​                </p>
<p>​    2.切片：slice（引用类型）</p>
<p>​        理解为变长的数组</p>
<p>​        A：切片创建</p>
<p>​            1.创建切片1.直接创建</p>
<p>​                 s1 := [] int{1,2,3,4,5,6,7,8}</p>
<p>​            2.使用make([]T, len,cap) cap如果不给数值，那么和len一致，                                         </p>
<p>​                 s2:=make([]T,len,cap)</p>
<p>​                 s3 := make([]int, 3, 8)</p>
<p>​            3.在数组的基础上创建切片</p>
<p>​                b := [10]int{1,2,3,4,5,6,7,8,9,10}</p>
<p>​                s4 := b[2:6] // 数组名[start:end），start，end指的是下标。不包含end</p>
<p>​                s5 := b[:6] // [0:6]，从头开始，切割刀下标6(不包含6)</p>
<p>​                s6 :=b[6:] // [start:],从start开始，切割刀最后</p>
<p>​        B：切片的类型：</p>
<p>​                []数据类型    </p>
<p>​                切片属于引用类型：</p>
<p>​                s1:=[] int{1,2,3,4}</p>
<p>​                s2:=s1</p>
<p>​            append(slice, ele1,ele2,ele3)//向切片后面直接加数值</p>
<p>​            append(slice1,slice2…)//向切片后面加切片，注意加 …</p>
<p>​        </p>
<h2 id="slice-copy和append方法"><a href="#slice-copy和append方法" class="headerlink" title="slice copy和append方法"></a>slice copy和append方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">len(),存储的实际的数量</span><br><span class="line">cap(),存储的最大的数量，自动扩容：规则：2倍</span><br><span class="line">append(slice, ele1,ele2,ele3)，增加同类型元素</span><br><span class="line">append(slice1,slice2...)，增加切片里元素</span><br><span class="line">cap:0--&gt;1--&gt;2--&gt;4--&gt;8--&gt;16--&gt;32，倍数增加容量</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝 numbers 的内容到 numbers1,如果numbers1的长度小于numbers，那么numbers1内的数值将被全部覆盖 </span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">12</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的</p>
</blockquote>
<p>Append里有个坑，详见例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   a := make([]int, 5, 10)</span><br><span class="line">   b := append(a, 1)//新开辟内存b，b内的值是指针传递，由a传递，a变化，b也会跟着相应变化</span><br><span class="line">   _ = append(a, 2)</span><br><span class="line">   a[0]=9</span><br><span class="line">   a=append(a,3,4,5)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line">   fmt.Printf(&quot;%p&quot;,&amp;b)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>[9 0 0 0 0 3 4 5]<br>[9 0 0 0 0 3]<br>0xc0420023e0<br>0xc042002400</p>
<h2 id="Map-字典"><a href="#Map-字典" class="headerlink" title="Map 字典"></a>Map 字典</h2><p>Map集合是引用类型：传递时候，传递的是地址。</p>
<pre><code>映射。存储一组无需的键值对的容器。
存储的特点：a.键与值是一一对应的。----&gt;映射
            b.键是唯一的
</code></pre><p>语法：<br>   A：创建：如果一个map仅有声明，就是nil map，不能直接存储数据<br>   var map名 [key类型]value类型<br>   map名:=map[key类型]value类型{}<br>   map名:=make(map[key类型]value类型)<br>   B：向map中添加数据<br>              map[key] = value</p>
<p>   C：获取map的数据：根据key获取value，如果key 不存在<br>         /<em> 使用 key 输出 map 值 </em>/<br>         map1:=make(map[int]string)<br>       for key := range map1 {<br>          fmt.Println(key,map1[key])<br>       }</p>
<pre><code>   /* 查看元素在集合中是否存在 */
   value, ok := map1[key]
   /* 如果 ok 是 true, 则存在，否则不存在 */
   if(ok){
      fmt.Println(value)  
   }else {
      fmt.Println(&quot;value is not present&quot;) 
   }
D：删除键值对
  delete(map,key)
  根据key删除键值对，如果key不存在，删除失败。
</code></pre><p>   E：修改：<br>      根据key修改<br>map的遍历：<br>创建slice，利用append函数，将map中的key值遍历再加入到slice中，排序<br>//1.定义一个slice<br>s1 := make([]int,0,len(map2))<br>//2.遍历map获取key–&gt;s1中<br>for key := range map2{<br>   s1 = append(s1, key)<br>}<br>//3.给s1进行排序<br>sort.Ints(s1)//使用sort包下的方法直接排序，不用自己写冒泡了。<br>//4. 遍历s1，map<br>for _,k:=range s1{ // 先下标，再数值<br>   fmt.Println(k, map2[k])<br>}</p>
<h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><p> 字符串：多个字节的集合。理解为一个字符序列。</p>
<p>​            //长度：字符串中的字节的数量。</p>
<p>​            //序列：有序–&gt;下标，也叫索引，每个字符的位置。从0开始，到长度减1。</p>
<p>​            遍历：可以根据字符的下标，进行访问遍历</p>
<p>​                 for i:=0;i&lt;len(s2);i++{</p>
<pre><code>//fmt.Println(s2[i])

fmt.Printf(&quot;%c\n&quot;,s2[i])
</code></pre><p>​                }</p>
<p>​            字符串—&gt;[]byte</p>
<p>​            []byte(s1)</p>
<p>​            string(arr1)</p>
<p>​        strings函数包使用方法：</p>
<p>​                s1:=”HelloWorld”</p>
<p>​                s2:=”20180403课堂笔记.txt”</p>
<p>​    1.strings.Contains(s,””)：返回值为bool    </p>
<p>​            是否包含指定内容，</p>
<p>​                        fmt.Println(strings.Contains(s1,”O”))</p>
<p>​                        //判断s1中是否包含“0”</p>
<p>​    2.strings.ContainsAny(s,””)：返回值为bool</p>
<p>​            是否包含指定内容中的任意一个，</p>
<p>​                        fmt.Println(strings.ContainsAny(s1,”abcd”))</p>
<p>​                        //判断s1中是否包含”abcd”中的任意一个</p>
<p>​    3.strings.HasPrefix(s,””)：返回值为bool</p>
<p>​            判断s是否有前缀字符串，</p>
<p>​                        if strings.HasPrefix(s2,”201804”) {</p>
<pre><code>fmt.Println(&quot;这个是4月份的笔记。。&quot;)
</code></pre><p>​                        }</p>
<p>​                        //判断s2是不是以”201804”为开头的</p>
<p>​    4.strings.HasSuffix(s,””)：返回值为bool</p>
<p>​            判断s是否有后缀字符串</p>
<p>​                    if strings.HasSuffix(s2,”.txt”){</p>
<pre><code>fmt.Println(&quot;这个是一个文本文档。。&quot;)
</code></pre><p>​                    }</p>
<p>​                    //判断s2是不是以”.txt”为结束的</p>
<p>​    5.strings.Index(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中第一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.Index(s1,”llo”))</p>
<p>​                        //查找s1第一次出现”llo”的下标，不存在则返回-1.</p>
<p>​    6.strings.LastIndex(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中最后一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.LastIndex(s1,”l”))</p>
<p>​                        //查找s1最后一次出现”l”的下标，不存在则返回-1</p>
<p>​    7.strings.Count(s,””):返回值为int。</p>
<p>​            统计s字符串中出现子串” “的次数。</p>
<p>​                        fmt.Println(strings.Count(s1,”l”))</p>
<p>​                        //统计s1中出现”l”的次数</p>
<p>​    8.strings.Split(s1,””): 返回值为[]string</p>
<p>​                 用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所</p>
<p>​            有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会</p>
<p>​            进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值</p>
<p>​            一个字符串。</p>
<p>​            fmt.Println(strings.Split(“a man a plan a canal panama”, “a “))</p>
<p>​                        [ man  plan  canal panama]</p>
<p>​            //去掉”a man a plan a canal panama”中的”a “，即遇到 “a “以空格代替</p>
<p>​    9.strings.SplitN(s1,””,n): 返回值为[]string</p>
<p>​            指定次数的切割，不超过n次，即切割（n-1）次。如果全切n=-1</p>
<p>​            n == 0: 返回nil</p>
<p>​    10.strings.Join([]strings,””):返回值为string</p>
<p>​            将一系列字符串连接为一个字符串，之间用sep来分隔。</p>
<p>​            input：  s := []string{“foo”, “bar”, “baz”}                fmt.Println(strings.Join(s, “, “))</p>
<p>​            output：  foo, bar, baz</p>
<p>​    11.strings.ToLower(s):转小写，返回值为string</p>
<p>​       strings.ToUpper(s):转大写，返回值为string</p>
<p>​            fmt.Println(strings.ToLower(s1))//转小写</p>
<p>​            fmt.Println(strings.ToUpper(s1))//转大写</p>
<p>​    12.strings.Trim(s,cutset string): 返回值为string</p>
<p>​        返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</p>
<p>​    13.strings.Replace(s,old,new,n)n替换的次数，-1表示全部替换 返回值为string</p>
<p>​    strings.Repeat(s string, count int),=重复的次数  返回值为string</p>
<h2 id="func（）函数"><a href="#func（）函数" class="headerlink" title="func（）函数"></a>func（）函数</h2><p>函数是执行特定任务的代码块，打印函数名输出地址</p>
<p>参数有值传递和引用传递，引用传递将参数类型设为指针，传参&amp;参数</p>
<p>函数参数可以是可变参，如func myfunc(nums …int) </p>
<p>闭包：Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数体为getSequence() 的返回值，以后nextNumber函数自己独立 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回，地址不变 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">  fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="panic-和recover"><a href="#panic-和recover" class="headerlink" title="panic()和recover()"></a>panic()和recover()</h2><p>panic()执行导致程序出现恐慌，系统运行终止。需要借助defer函数使recover()接收错误，并恢复其他函数运行</p>
<p>panic()输出位置不固定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)//主函数终止，无法输出</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机输出1：</p>
<p>0<br>panic: 3<br>1</p>
<p>2<br>goroutine 1 [running]:<br>main.a()<br>    E:/kyxy/day01/ceshi.go:14 +0xed<br>main.main()<br>    E:/kyxy/day01/ceshi.go:8 +0x29</p>
<p>随机输出2：</p>
<p>panic: 3<br>0</p>
<p>1<br>goroutine 1 [running]:<br>2<br>main.a()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:14 +0xed</span><br></pre></td></tr></table></figure>
<p>main.main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:8 +0x29</span><br></pre></td></tr></table></figure>
<p>使用recover()，主函数输出有序，只是有panic的函数因panic动作，该函数panic后不能继续运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      defer func() &#123;</span><br><span class="line">         if r := recover(); r != nil &#123;</span><br><span class="line">            fmt.Println(&quot;系统出现panic&quot;, r)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>0<br>1<br>2<br>系统出现panic 3<br>hello</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>​    定义指针：</p>
<p>​        var p1 *T</p>
<p>​    &amp;,取地址</p>
<p>​    *,取指针中地址对应的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   /*</span><br><span class="line">   指针：存储另一个变量的内存地址的变量。</span><br><span class="line">   指针的类型，</span><br><span class="line">   指针存储的数据的类型</span><br><span class="line">   指针的地址</span><br><span class="line">   指针存储的变量的地址</span><br><span class="line">    */</span><br><span class="line">    a:=100 //定义了一个变量，变量名：a，变量值：100，变量类型int</span><br><span class="line">    fmt.Printf(&quot;变量的数值：%d，变量的类型：%T\n&quot;,a,a)</span><br><span class="line">    //&amp;,获取变量的内存地址</span><br><span class="line">    fmt.Printf(&quot;变量a的内存地址：%p\n&quot;,&amp;a) //0xc04200e098</span><br><span class="line"></span><br><span class="line">    // 修改变量的值</span><br><span class="line">    a = 200//修改a的数值</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line"></span><br><span class="line">    //创建一个指针</span><br><span class="line">    var p1 *int</span><br><span class="line">    fmt.Println(p1) //&lt;nil&gt; 空 null</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p1) //*int</span><br><span class="line">    fmt.Printf(&quot;p1自己的地址：%p\n&quot;,&amp;p1)</span><br><span class="line">    p1 = &amp;a //取a的地址，赋值给p1</span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">    fmt.Println(&quot;获取数值：&quot;,*p1)</span><br><span class="line"></span><br><span class="line">    // 指针的的指针</span><br><span class="line">    var p2 **int</span><br><span class="line">    fmt.Println(p2) //nil</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p2) //**int</span><br><span class="line">    p2 = &amp;p1 // int--&gt;*int</span><br><span class="line">    fmt.Printf(&quot;p2中存储的数据，就是p1的地址：%p\n&quot;,p2)//p2的值，就是p1的地址</span><br><span class="line">    fmt.Printf(&quot;p2自己的地址：%p\n&quot;,&amp;p2)//p2的地址：</span><br><span class="line"></span><br><span class="line">    fmt.Println(*p1) //*,获取p1指针中存储的内存地址对应的数据。 200</span><br><span class="line">    fmt.Println(*p2) // *p2取值的a的地址</span><br><span class="line">    fmt.Println(**p2)</span><br></pre></td></tr></table></figure>
<p>指针更改数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   a := 100</span><br><span class="line">   p1 := &amp;a</span><br><span class="line">   fmt.Println(a, *p1)//100 100</span><br><span class="line">   *p1++// 操作指针更改变量的数值</span><br><span class="line">   fmt.Println(a, *p1)//101 101</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针及地址打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var a *int</span><br><span class="line">   p:=&amp;a</span><br><span class="line">fmt.Println(*p)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <nil><br>​            0xc042004028</nil></p>
<p>空指针：只声明一个指针不给赋值叫空指针，但是可以给空指针赋值地址，将不再是空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var p *int</span><br><span class="line">   a:=10</span><br><span class="line">   p=&amp;a</span><br><span class="line">   fmt.Println(p)</span><br><span class="line">   fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：0xc04204a080<br>​            10</p>
<h2 id="new-和make-区别"><a href="#new-和make-区别" class="headerlink" title="new()和make()区别"></a>new()和make()区别</h2><p><strong>new()</strong><br>这是一个用来分配内存的内置函数，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配的 t 类型的零值的指针。</p>
<p>在golang的代码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(t Type) *Type</span><br></pre></td></tr></table></figure>
<p>直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针,new()返回值是指针。两者是不一样的</p>
<p>两者对比代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>new()与make()区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">new 主要用于结构体的初始化</span><br><span class="line"></span><br><span class="line">make用于数组array，切片slice，协程chnnel的初始化</span><br><span class="line">例如：  users:=make([10]int);</span><br><span class="line">             msg:=make(chan int);</span><br><span class="line"></span><br><span class="line">     new会分配结构空间，并初始化为清空为零，不进一步初始化</span><br><span class="line">     new之后需要一个指针来指向这个结构</span><br><span class="line">     make会分配结构空间及其附属空间，并完成其间的指针初始化</span><br><span class="line">     make返回这个结构空间，不另外分配一个指针</span><br><span class="line">例子new：</span><br><span class="line">     var p *[]int = new([]int)</span><br><span class="line">     或</span><br><span class="line">     p := new([]int)</span><br><span class="line">     以上分配了一个slice结构，但是结构中的应该指向底层数组的ptr指针为空，故实际不能往这个slice里面存取数据</span><br><span class="line">     同时分配了一个指针p，也即(在32位系统中)占4个字节并存放slice结构的地址</span><br><span class="line">例子make：</span><br><span class="line">     var v []int = make([]int, 0)</span><br><span class="line">     v := make([]int, 0)</span><br><span class="line">     以上分配了一个slice结构，且结构中的应该指向底层数组的ptr指针已经指向了某个底层数组，这个底层数组应该已经分配了，故这个slice已经可以使用了</span><br><span class="line">     注意v就是这个slice结构，而不是一个指向slice的指针</span><br><span class="line">     上述仅是示例，一般使用时都会明确长度和容量：v := make([]int, 10, 50)</span><br><span class="line">结论：</span><br><span class="line">     由上可见，用new来分配slice的意义不大，因为没有恰当的初始化，无法直接使用</span><br><span class="line">     有附带空间的结构，使用make来初始化，可以完成内部指针初始化，其后可以立即使用</span><br></pre></td></tr></table></figure>
<h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct{}"></a>结构体struct{}</h2><p>面向对象：不是一门语言，也不是一门技术，而是一种编程思路。</p>
<p>面向对象：<br>    A：考虑问题域中涉及到的对象<br>    B：定义这些对象—&gt;类<br>    C：思考类和类的关系<br>类，对象：面向对象中的量大核心概念<br>类：同一类事物的抽象描述。<br>    静态属性：字段<br>    动态属性：方法<br>对象：类中一个具体的实例。<br>    对象是存在，<br>类和对象的关系？<br>    类是对象的抽象描述，对象是类的一个具体的实例。<br>    将一类对象共同特征，进行抽取—-&gt;定义类<br>    将类进行实例化—&gt;创建对象<br>type Person struct{<br>    name, age, sex<br>}</p>
<p>p1 := Person{“王二狗”,30,”男”} // 将类进行实例化得到对象。<br>p2 := Preson{“李小花”,18,”女”}<br>面向对象的三大特征：<br>1.封装性：<br>    “打包”<br>    函数，方法，结构体。。。<br>2.继承性：<br>    描述一个类和另一个类的关系。<br>    子类继承父类：<br>        子类可以直接访问父类的属性和方法。<br>        子类可以新增自己的属性和方法<br>        子类可以重写父类已有的方法。<br>    靠结构体的嵌套：<br>        匿名字段：提升字段</p>
<pre><code>3.多态性：接口
</code></pre><p>二.结构体<br>1.定义一个结构体<br>type 结构体名 struct{<br>   字段名 类型<br>}<br>type person1 struct {<br>   name string //姓名<br>   age int // 年龄<br>   sex string // 性别<br>}<br>根据类实例化对象：根据结构体创建该结构体类型的变量</p>
<p>2、创建对象：<br>    对象名 := 结构体名{val1,val2,val3…} //保证顺序<br>        p2 := person1{“李小花”, 18,”女”} //注意赋值顺序<br>    对象名 := 结构体名{字段名:val1,字段名:val2,…}<br>        p3 := person1{age:30,sex:”男”,name:”三胖”}<br>    对象名 := 结构体名{}<br>对象名.字段名 ，进行赋值和取值<br>    var p1 person1<br>    p1.name = “王二狗”<br>p1.age = 30<br>p1.sex = “男”<br>对象名 := new(Type) //指针<br>    p5 := new(person1)<br>fmt.Printf(“%T\n”,p5) //<em>main.person1<br>(</em>p5).name=”隔壁老王”<br>p5.age = 30 // 简写<br>p5.sex = “男”<br>fmt.Println(p5) //&amp;{隔壁老王 30 男}<br>结构体为值类型<br>    结构体：<br>   值类型：<br>      p1 := person{…..}<br>   浅拷贝：<br>      指针：<br>         p2:=new(person)<br>         p3:= &amp;p1<br>3.匿名结构体<br>    匿名结构体和匿名字段<br>           匿名结构体：没有名字的结构体<br>                   匿名字段：没有名字的字段，但是有类型。相当于该类型就是字段名<br>                注意点：一个结构体中，匿名字段的类型是唯一的。<br>                创建结构体对象：<br>           对象名:=结构体名{field:value,field:value…}<br>            结构体的嵌套：<br>           一个结构体作为另一个结构体的字段类型<br>三.结构体的嵌套<br>    继承：两个类的继承关系。子类可以使用父类的功能<br>对于go语言，没有真正的继承。靠结构体的嵌套模拟继承功能的。<br>结构体的嵌套：<br>   聚合关系：一个类作为另一个类的属性。has - a<br>      type A struct{}<br>      type B struct{<br>         a A<br>      }<br>   继承关系：一个子类继承一个父类。is - a<br>      type C struct{}<br>      type D struct{<br>         C<br>      }<br>继承：<br>    子类，父类<br>    子类 继承了父类<br>        1.子类可以直接使用父类的属性和方法。<br>        2.子类可以新增自己的属性和方法<br>        3.子类可以重写父类已有的方法</p>
<pre><code>作用和意义：
    1.可以避免重复的代码。
    2.扩展类的功能。(从父类角度)
</code></pre><h2 id="方法methed"><a href="#方法methed" class="headerlink" title="方法methed"></a>方法methed</h2><h3 id="1-1-什么是方法"><a href="#1-1-什么是方法" class="headerlink" title="1.1 什么是方法"></a>1.1 什么是方法</h3><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集</p>
<p>方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。</p>
<h3 id="1-2-方法的语法"><a href="#1-2-方法的语法" class="headerlink" title="1.2 方法的语法"></a>1.2 方法的语法</h3><p>定义方法的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span> <span class="title">methodName</span><span class="params">(parameter list)</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method has Employee as the receiver type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">displaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">//Calling displaySalary() method of Employee type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以定义相同的方法名</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Area of r1 is: "</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of r2 is: "</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c1 is: "</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c2 is: "</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Area of r1 is:  24</span><br><span class="line">Area of r2 is:  36</span><br><span class="line">Area of c1 is:  314.1592653589793</span><br><span class="line">Area of c2 is:  1963.4954084936207</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过.访问，就像struct里面访问字段一样 </li>
</ul>
<h3 id="1-3-方法和函数"><a href="#1-3-方法和函数" class="headerlink" title="1.3 方法和函数"></a>1.3 方法和函数</h3><p>既然我们已经有了函数，为什么还要使用方法？</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method converted to function with Employee as parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。</p>
</blockquote>
<p>为什么我们可以用函数来写相同的程序呢?有以下几个原因</p>
<ol>
<li>Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。</li>
<li>相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。</li>
</ol>
<h3 id="1-4-变量作用域"><a href="#1-4-变量作用域" class="headerlink" title="1.4 变量作用域"></a>1.4 变量作用域</h3><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p><strong>局部变量</strong></p>
<p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p><strong>全局变量</strong></p>
<p>在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"结果： a = %d, b = %d and g = %d\n"</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果： a = <span class="number">10</span>, b = <span class="number">20</span> and g = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>形式参数</strong></p>
<p>形式参数会作为函数的局部变量来使用</p>
<p><strong>指针作为接收者</strong></p>
<p>若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">SetColor</span><span class="params">(c Color)</span></span> &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>例</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span> <span class="title">setVal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.height = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Rectangle&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := p</span><br><span class="line">	p.setVal()</span><br><span class="line">	fmt.Println(p.height, s.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果没有那个*，则值就是<code>2 2</code></p>
<h3 id="1-5-method继承"><a href="#1-5-method继承" class="headerlink" title="1.5 method继承"></a>1.5 method继承</h3><p>method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam you can call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<h3 id="1-6-method重写"><a href="#1-6-method重写" class="headerlink" title="1.6 method重写"></a>1.6 method重写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam, I work at Golang Inc. Call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<ul>
<li>方法是可以继承和重写的</li>
<li>存在继承关系时，按照就近原则，进行调用</li>
</ul>
<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><h3 id="一-error"><a href="#一-error" class="headerlink" title="一.error"></a>一.error</h3><pre><code>异常：不正常，程序中存在不正常的事件，导致程序无法正常的执行。
error,错误，来表示程序中的不正常。
    函数() 返回值：error
error 本质上是一个接口，所有能实现 函数名为Error（）返回值为string 方法的结构体都是error的实现类。
    type error interface {
       Error() string
    }
go语言中提供两个函数来实现 返回值string
  errors.New(string)--&gt;error
  fmt.Errorf(format)--&gt;error
error：nil，表示没有错误    
error：Go中表示不正常的错误的类型。

1.2自定义error的实现类
    1.定义一个结构体，实现error接口。即该结构体有个如下的方法
        func (s struct)Error() string{
        //该函数中的返回值string 可以用 fmt.Sprintf()函数实现。改函数即将打印的内            
        容转为string类型
        }
    2：使用--&gt;
                创建error对象，创建自定义实现类的对象即可。
</code></pre><h3 id="二-strconv：字符串和基本类型之间的转换"><a href="#二-strconv：字符串和基本类型之间的转换" class="headerlink" title="二.strconv：字符串和基本类型之间的转换"></a>二.strconv：字符串和基本类型之间的转换</h3><pre><code>string与其他数据类型的转换
</code></pre><p>string–&gt;int,float64,bool….<br>   ParseXXX()<br>      ParseInt(),ParseBool(),ParseFloat()</p>
<p>int,float,bool—&gt;string<br>      FormatXXX()<br>      FormatBool(),FormatInt(),FormatFloat()</p>
<p>Atoi(string)–&gt;int,10进制<br>Itoa(int)–&gt;string,10进制整数–&gt;字符串<br>​    </p>
<h3 id="三-math包"><a href="#三-math包" class="headerlink" title="三.math包"></a>三.math包</h3><p>fmt.Println(math.Abs(float64(i))) //绝对值<br>fmt.Println(math.Ceil(5.0))       //向上取整<br>fmt.Println(math.Floor(5.8))      //向下取整<br>fmt.Println(math.Mod(11, 3))      //取余数，同11%3<br>fmt.Println(math.Modf(5.26))      //取整数，取小数<br>fmt.Println(math.Pow(3, 2))       //x的y次方<br>fmt.Println(math.Pow10(4))        // 10的n次方<br>fmt.Println(math.Sqrt(8))         //开平方<br>fmt.Println(math.Cbrt(8))         //开立方</p>
<h3 id="四-time包"><a href="#四-time包" class="headerlink" title="四.time包"></a>四.time包</h3><pre><code>1.获取时间对象
t1 := time.Now() // 当前的时间
2.创建指定的时间
</code></pre><p>t2 := time.Date(1998,4,12,16,34,0,0,time.Local)<br>fmt.Println(t2)<br>//获取日期<br> year,month,day:=t1.Date()<br> fmt.Println(“年，月，日：”,year,month,day)<br> //获取时间<br> hour,minute,second := t1.Clock()<br> fmt.Println(“时，分，秒：”, hour,minute,second)<br>//获取年，月，日，时，分，秒，星期，纳秒，。。<br>fmt.Println(“年：”, t1.Year()) //年<br>fmt.Println(“月：”,t1.Month())//月<br>fmt.Println(“日：”,t1.Day())//日<br>fmt.Println(“时：”,t1.Hour())//时<br>fmt.Println(“分：”,t1.Minute())//分<br>fmt.Println(“秒：”,t1.Second())//秒<br>fmt.Println(“纳秒：”,t1.Nanosecond())//纳秒<br>fmt.Println(“星期：”,t1.Weekday())//星期<br>fmt.Println(t1.ISOWeek()) //返回年份，第几周<br>fmt.Println(t1.YearDay())<br>//timestamp,时间戳：<br>日期，距离1970年1月1日，0点0时，0分0秒，时间的差值<br>    timeStamp1:=t4.Unix() //秒 差值 3600<br>            timeStamp2:=t4.UnixNano()//纳秒</p>
<pre><code>Duration,时间间隔
t1 := time.Now()
        t2 := t1.Add(time.Nanosecond)//在当前时间上，累加1纳秒，nanosecond即为1
        t3 := t1.Add(time.Minute)// 当前时间上，累加1分钟
        t4:=t1.Add(time.Hour * 24)//当前时间，类加1天
        t5:=t1.AddDate(0,0,3)//累加：年，月，日
</code></pre><p>//两个time之间的间隔<br>    d1:= t1.Sub(t5) //t1-t2<br>//睡眠<br>//time.Sleep(time.Nanosecond)//睡眠1纳秒<br>//time.Sleep(5 * time.Second) //当前正在执行的程序进入睡眠。。<br>//fmt.Println(“over….”)</p>
<p>//睡眠，随机数：[1-10]s<br>// [m,n], rand.Intn(n-m+1)+m<br>rand.Seed(time.Now().UnixNano())<br>num := rand.Intn(10) + 1 //<br>fmt.Println(num)<br>time.Sleep(time.Duration(num) * time.Second)<br>fmt.Println(“睡眠结束。。。”)</p>
<h2 id="文件读写-read-write"><a href="#文件读写-read-write" class="headerlink" title="文件读写 read()  write()"></a>文件读写 read()  write()</h2><p>一.文件，路径</p>
<pre><code>文件，目录
目录：directory
    文件存储的路径位置。
文件：file
    用于存储数据，靠文件的类型存储不同类型的数据。
数据存储：
    程序执行过程中产生的数据：存储在内存中。---&gt;瞬时性。
    文件，硬盘上。持久化存储数据。
程序的执行：
    CPU，内存
文件路径：
    绝对路径：
        从跟盘符开始的路径。
    相对路径：
        参照物。go里面以当前的项目的路径，为相对路径的参照物。
</code></pre><p>二.os包：文件操作<br>文件的信息可以读取进一个[]byte切片。Read和Write方法从切片参数获取其内的字节数。<br>    1.os.Stat<br>    os.Stat(“pathname”)<br>    返回值有两个<br>    fi ：<br>         type FileInfo interface {<br>            Name() string       // 文件的名字（不含扩展名）<br>            Size() int64        // 普通文件返回值表示其大小；其他文件的返回值<br>                                含义各系统不同<br>           Mode() FileMode     // 文件的模式位<br>            ModTime() time.Time // 文件的修改时间<br>            IsDir() bool        // 等价于Mode().IsDir()<br>            Sys() interface{}   // 底层数据来源（可以返回nil）<br>      }<br>    err：该文件路径不正确返回的值<br>2.os.mkdir(“pathname”)–&gt;创建文件，仅一层<br>  os.mkdirall(“pathname”)–&gt;创建文件，可以多层<br>      os.create(“pathname”) <em>file,err–&gt;创建空文件<br>      os.open()</em>file,err–&gt;打开文件<br>  os.remove(),删除文件或文件夹，慎用！！！！<br>      os.removeall(),删除所有，慎用！！！！<br>3.关闭文件<br>defer file.Close()//断开程序和文件之间的链接，释放资源。<br>// 读操作，写数据。。。<br>4.os.Open(“文件名”)–&gt;file指针对象<br>Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是<em>PathError。<br>    表示程序中打开文件，和文件建立连接，可以操作文件了。<br>    就是操作file对象，就是操作文件。。<br>os.OpenFile<br>    OpenFile(filename，flag，perm)–&gt;</em>File,err  <strong>*</strong><br>            filename：文件名字<br>            flag，获取file的打开模式：<br>                O_RDONLY<br>                O_WRONLY<br>                O_RDWR<br>                O_CREATE</p>
<pre><code>perm，如果文件不存在，需要指定创建的文件的权限
    0777,0666
    -rw-
</code></pre><p>5.文件读写<em>**<br>    Read([]byte)–&gt;count,err，读取数据<br>默认从头开始读取<br>   光标在最后，再次读取，返回error为io.EOF<br>    func (f </em>File) Read(b []byte) (n int, err error)<br>    Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。</p>
<pre><code>ReadAt([] byte, off)--&gt;coutn,err，从指定off位置读取
    unc (f *File) ReadAt(b []byte, off int64) (n int, err error)
ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。

Write([]byte)--&gt;count,err，写出字节数组
    func (f *File) Write(b []byte) (n int, err error)
Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteAt([]byte,off)，在指定位置写出数据。
    func (f *File) WriteAt(b []byte, off int64) (n int, err error)
    WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteString(string)，直接写出字符串
    func (f *File) WriteString(s string) (ret int, err error)
    WriteString类似Write，但接受一个字符串参数。

Seek(offset, whence)，设置光标的未知
    offset,偏移量
    whence，从哪开始：0从头，1当前，2末尾

    filepath包
        Abs()
            获取绝对路径：程序中以当前工程为参照。
        IsAbs()
            判断是否是绝对路径

        绝对路径：Absolute
            从跟盘符开始描述

        相对路径：Relative
            相对于参照物
</code></pre><p>三.io/ioutil包<br>    io包<br>        Copy(Write，Reader)–&gt;total,err<br>            拷贝文件<br>        func copyFile2(destName, srcName string)(int64, error){<br>   srcFile ,err:= os.Open(srcName)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer srcFile.Close()<br>   destFile,err:=os.OpenFile(destName,os.O_WRONLY|os.O_CREATE,0777)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer destFile.Close()<br>   return io.Copy(destFile,srcFile)<br>}</p>
<p>ioUtil包<br>    ReadFile(filename)–&gt;data []byte   <strong>*</strong><br>        读取指定文件中的所有内容<br>    WriteFile(filename, data [] byte,FileMode) <strong>*</strong><br>        向指定文件中写出数据，</p>
<pre><code>ReadAll()

ReadDir(dirname)--&gt;[]FileInfo
    获取指定目录下的子内容，只有一层
</code></pre><p>​<br>​<br>​<br>​        </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-第18章-反射"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/04/21/第18章-反射/">反射reflect</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2018/04/21/第18章-反射/" class="article-date">
	  <time datetime="2018-04-21T12:53:11.000Z" itemprop="datePublished">四月 21, 2018</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>#反射reflect</p>
<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>Java的反射机制是其标志性的特征之一，正是这种语言本身支持的强大的机制使得很多流行的框架有了用武之地。C++中虽然也能实现，但是语言本身并没有提供标准的支持。<br>而作为一门现代的语言，go语言也引入了反射机制，在这篇文章中我们将会了解一下go语言中的反射机制是如何使用的。</p>
<p>反射机制<br>反射机制是程序能够检查其自身结构，属于元编程的范畴，强大的同时也往往是困扰的源头。虽然各种语言的反射模型有所不同，但是通过简单的比较也能有所收获。在了解Go的反射机制之前先来看看Java的反射机制吧。</p>
<p>Java的反射机制<br>我们所熟知的Java的反射机制是什么？对于类和对象的使用，普通的方式是知道类和对象的属性和方法之后进行调用或者访问。<br>而反射机制，简单来说，是在运行状态中，Java对于任何的类，都能够确认到这个类的所有方法和属性；对于任何一个对象，都能调用它的任意方法和属性。这种动态获取或者调用的方式就是Java的反射机制。</p>
<p>能做什么<br>在Java中，通过反射机制在运行时能够做到如下：</p>
<p>确认对象的类<br>确认类的所有成员变量和方法<br>动态调用任意一个对象的方法<br>…</p>
<h2 id="二、相关基础"><a href="#二、相关基础" class="headerlink" title="二、相关基础"></a>二、相关基础</h2><p>在进行更加详细的了解之前，我们需要重新温习一下Go语言相关的一些特性，所谓温故知新，从这些特性中了解其反射机制是如何使用的。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>go语言是静态类型语言。</td>
<td>编译时类型已经确定，比如对已基本数据类型的再定义后的类型，反射时候需要确认返回的是何种类型。</td>
</tr>
<tr>
<td>空接口interface{}</td>
<td>go的反射机制是要通过接口来进行的，而类似于Java的Object的空接口可以和任何类型进行交互，因此对基本数据类型等的反射也直接利用了这一特点</td>
</tr>
</tbody>
</table>
<h2 id="三、反射的使用"><a href="#三、反射的使用" class="headerlink" title="三、反射的使用"></a>三、反射的使用</h2><p>所谓反射就是动态运行时的状态。我们一般用到的包是reflect包</p>
<p>使用reflect一般分成三步：</p>
<p>首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i) <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i) <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>
<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br></pre></td></tr></table></figure>
<p>如果是struct的话，可以使用Elem()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag <span class="comment">//获取定义在struct里面的Tag属性</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String() <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()<span class="comment">//必须的步骤</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//1.“接口类型变量”=&gt;“反射类型对象”</span></span><br><span class="line">	<span class="keyword">var</span> circle <span class="keyword">float64</span> = <span class="number">6.28</span></span><br><span class="line">	<span class="keyword">var</span> icir <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	icir = circle</span><br><span class="line">	fmt.Println(<span class="string">"Reflect : circle.Value = "</span>, reflect.ValueOf(icir)) <span class="comment">//Reflect : circle.Value =  6.28</span></span><br><span class="line">	fmt.Println(<span class="string">"Reflect : circle.Type  = "</span>, reflect.TypeOf(icir)) <span class="comment">//Reflect : circle.Type =  float64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. “反射类型对象”=&gt;“接口类型变量</span></span><br><span class="line">	v1 := reflect.ValueOf(icir)</span><br><span class="line">	fmt.Println(v1) <span class="comment">//6.28</span></span><br><span class="line">	fmt.Println(v1.Interface()) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	y := v1.Interface().(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(y) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//v1.SetFloat(4.13) //panic: reflect: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">	<span class="comment">//fmt.Println(v1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.修改</span></span><br><span class="line">	fmt.Println(v1.CanSet())<span class="comment">//是否可以进行修改</span></span><br><span class="line">	v2 := reflect.ValueOf(&amp;circle) <span class="comment">// 传递指针才能修改</span></span><br><span class="line">	v4:=v2.Elem()<span class="comment">// 传递指针才能修改,获取Elem()才能修改</span></span><br><span class="line">	fmt.Println(v4.CanSet()) <span class="comment">//true</span></span><br><span class="line">	v4.SetFloat(<span class="number">3.14</span>)</span><br><span class="line">	fmt.Println(circle) <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、结构体"><a href="#四、结构体" class="headerlink" title="四、结构体"></a>四、结构体</h2><h3 id="4-1可以通过反射，获取结构体对象的属性和方法"><a href="#4-1可以通过反射，获取结构体对象的属性和方法" class="headerlink" title="4.1可以通过反射，获取结构体对象的属性和方法"></a>4.1可以通过反射，获取结构体对象的属性和方法</h3><h3 id="4-2可以通过反射，调用结构体方法"><a href="#4-2可以通过反射，调用结构体方法" class="headerlink" title="4.2可以通过反射，调用结构体方法"></a>4.2可以通过反射，调用结构体方法</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.提供一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.提供一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Say</span><span class="params">(msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello.."</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">PrintInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"姓名："</span>,p.Name,<span class="string">"年龄："</span>,p.Age,<span class="string">"性别："</span>,p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	p1:=Person&#123;<span class="string">"王二狗"</span>,<span class="number">30</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">	<span class="comment">//反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</span></span><br><span class="line">	<span class="comment">//1.获取对象的类型</span></span><br><span class="line">	t1:=reflect.TypeOf(p1)</span><br><span class="line">	fmt.Println(t1) <span class="comment">//main.Person</span></span><br><span class="line">	fmt.Println(<span class="string">"p1的类型是："</span>,t1.Name())<span class="comment">//调用t.Name方法来获取这个类型的名称</span></span><br><span class="line">	k1:=t1.Kind() <span class="comment">//struct</span></span><br><span class="line">	fmt.Println(k1)</span><br><span class="line">	<span class="comment">//2.获取值，如果是结构体类型，获取的是字段的值</span></span><br><span class="line">	v1:=reflect.ValueOf(p1) <span class="comment">//&#123;王二狗 30 男&#125;</span></span><br><span class="line">	fmt.Println(v1)</span><br><span class="line">	<span class="keyword">if</span> t1.Kind() == reflect.Struct&#123;</span><br><span class="line">		<span class="comment">//是结构体类型，获取里面的字段名字</span></span><br><span class="line">		fmt.Println(t1.NumField()); <span class="comment">//3</span></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumField();i++&#123;</span><br><span class="line">			field := t1.Field(i)</span><br><span class="line">			<span class="comment">//fmt.Println(field) //&#123;Name  string  0 [0] false&#125;,&#123;Age  int  16 [1] false&#125;,&#123;Sex  string  24 [2] false&#125;</span></span><br><span class="line">			val:=v1.Field(i).Interface()<span class="comment">//通过interface方法来取出这个字段所对应的值</span></span><br><span class="line">			fmt.Printf(<span class="string">"字段名字：%s,字段类型：%s,字段数值：%v\n"</span>,field.Name,field.Type,val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.操作方法</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumMethod();i++&#123;</span><br><span class="line">		m:=t1.Method(i)</span><br><span class="line">		fmt.Println(m.Name,m.Type) <span class="comment">//Hello func(main.Person)</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		&#123;Hello  func(main.Person) &lt;func(main.Person) Value&gt; 0&#125;</span></span><br><span class="line"><span class="comment">		&#123;PrintInfo  func(main.Person) &lt;func(main.Person) Value&gt; 1&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m1 := v1.MethodByName(<span class="string">"Say"</span>)</span><br><span class="line">	args:=[]reflect.Value&#123;reflect.ValueOf(<span class="string">"干啥呢？"</span>)&#125;</span><br><span class="line">	m1.Call(args)</span><br><span class="line"></span><br><span class="line">	m2:=v1.MethodByName(<span class="string">"PrintInfo"</span>)</span><br><span class="line">	m2.Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体中包含匿名结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal</span><br><span class="line">	Color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取匿名字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	c1:= Cat&#123;Animal&#123;<span class="string">"猫咪"</span>,<span class="number">1</span>&#125;,<span class="string">"白色"</span>&#125;</span><br><span class="line">	t1:=reflect.TypeOf(c1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumField();i++&#123;</span><br><span class="line">		fmt.Println(t1.Field(i))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		&#123;Animal  main.Animal  0 [0] true&#125;</span></span><br><span class="line"><span class="comment">		&#123;Color  string  24 [1] false&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// FiledByIndex()的参数是一个切片，第一个数是Animal字段，第二个参数是Animal的第一个字段</span></span><br><span class="line">	f1:=t1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">	f2:=t1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;)</span><br><span class="line">	fmt.Println(f1)<span class="comment">//&#123;Name  string  0 [0] false&#125;</span></span><br><span class="line">	fmt.Println(f2) <span class="comment">//&#123;Age  int  16 [1] false&#125;</span></span><br><span class="line"></span><br><span class="line">	v1:=reflect.ValueOf(c1)</span><br><span class="line">	fmt.Println(v1.Field(<span class="number">0</span>)) <span class="comment">//&#123;猫咪 1&#125;</span></span><br><span class="line">	fmt.Println(v1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)) <span class="comment">//猫咪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-可以通过反射，修改结构体的数据"><a href="#4-3-可以通过反射，修改结构体的数据" class="headerlink" title="4.3.可以通过反射，修改结构体的数据"></a>4.3.可以通过反射，修改结构体的数据</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	修改内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s1:= Student&#123;<span class="string">"王二狗"</span>,<span class="number">18</span>,<span class="string">"清华大学"</span>&#125;</span><br><span class="line">	v1 := reflect.ValueOf(&amp;s1)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> v1.Kind() ==reflect.Ptr &amp;&amp; v1.Elem().CanSet()&#123;</span><br><span class="line">		v1 = v1.Elem()</span><br><span class="line">		fmt.Println(<span class="string">"可以修改。。"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f1:=v1.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">	fmt.Println(f1.CanSet())</span><br><span class="line">	f1.SetString(<span class="string">"王三狗"</span>)</span><br><span class="line">	f2:=v1.FieldByName(<span class="string">"Age"</span>)</span><br><span class="line">	fmt.Println(f2.CanSet())</span><br><span class="line">	f2.SetInt(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
            
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">联系我们</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
          
     			  <li><a href="https://github.com/iTimeTraveler" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="http://www.yoursite.com" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Pinterest"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li> 
          
   		
          
     			  <li><a href="" title="Flickr"><i class="fa fa-flickr" aria-hidden="true"></i></a></li> 
          
   		
          
            <li><a href="mailto:?subject=请联系我&body=我能帮你什么" title="email"><i class="fa fa-envelope" aria-hidden="true"></i></a></li> 
          
   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/06/11/虚拟货币的认识/">(no title)</a></h6>
              <span>六月 11, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/29/分布式终端与go编程添加和删除节点/">(no title)</a></h6>
              <span>五月 29, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/29/分布式/">(no title)</a></h6>
              <span>五月 29, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/28/Unmarshal及json标签和marshal/">(no title)</a></h6>
              <span>五月 28, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/26/go语言下的http包/">(no title)</a></h6>
              <span>五月 26, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/21/POW共识算法/">(no title)</a></h6>
              <span>五月 21, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 Hexo All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

<!-- Custome JS -->
<script src="/js/my.js"></script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
