<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Hexo" rel="home"> Hexo </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-Golang细节汇总"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/05/02/Golang细节汇总/">go语言细节及重点汇总</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/05/02/Golang细节汇总/" class="article-date">
	  <time datetime="2018-05-02T13:53:12.506Z" itemprop="datePublished">May 2, 2018</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Golang细节汇总"><a href="#Golang细节汇总" class="headerlink" title="Golang细节汇总"></a>Golang细节汇总</h1><h2 id="mac-goland-安装"><a href="#mac-goland-安装" class="headerlink" title="mac goland 安装"></a>mac goland 安装</h2><p>mac系统安装并配置</p>
<p>安装</p>
<p>双击pkg包，顺着指引，即可安装成功。 </p>
<p>在命令行输入 go version，获取到go的版本号，则代表安装成功。</p>
<p>配置环境变量</p>
<p>1、打开终端输入cd ~进入用户主目录; </p>
<p>2、输入ls -all命令查看是否存在.bash_profile; </p>
<p>3、存在既使用vim .bash_profile 打开文件; </p>
<p>4、输入 i 进入vim编辑模式； </p>
<p>5、输入下面代码， </p>
<p>其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。</p>
<p>export GOPATH=/Users/ruby/go</p>
<p>export GOBIN=$GOPATH/bin</p>
<p>export PATH=$PATH:$GOBIN</p>
<p>6、点击ESC，并输入 :wq 保存并退出编辑。可输入vim .bash_profile 查看是否保存成功。</p>
<p>7、输入source ~/.bash_profile 完成对golang环境变量的配置，配置成功没有提示。 </p>
<p>8、输入go env 查看配置结果</p>
<h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><p>正数的原码，反码，补码都是二进制的本身（第一位表示符号位）</p>
<p>负数的第一位为1，表示负数</p>
<p>负数的反码是在其原码的基础上，符号位不变，其余各位按位取反</p>
<p>负数的补码是反码+1</p>
<p>计算机存储数值都是二进制，而且是以补码的形式存储。为了解决负数问题</p>
<h2 id="switch-fallthrough用法"><a href="#switch-fallthrough用法" class="headerlink" title="switch fallthrough用法"></a>switch fallthrough用法</h2><p><1> 如需贯通后续的case，就添加fallthrough</1></p>
<p>如：</p>
<pre><code>switch x := 5; x {
default:
    fmt.Println(x)
case 5:
    x += 10
    fmt.Println(x)
    fallthrough
case 6:
    x += 20
    fmt.Println(x)

}
</code></pre><p>输出</p>
<p>15<br>35</p>
<p><2>case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。</2></p>
<pre><code>func main(){
num := 75
switch { // expression is omitted
case num &gt;= 0 &amp;&amp; num &lt;= 50:
    fmt.Println(&quot;num is greater than 0 and less than 50&quot;)
case num &gt;= 51 &amp;&amp; num &lt;= 100:
    fmt.Println(&quot;num is greater than 51 and less than 100&quot;)
case num &gt;= 101:
    fmt.Println(&quot;num is greater than 100&quot;)
      }
}
</code></pre><p><3>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</3></p>
<p>语法以及举证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">" x 的类型 :%T"</span>,i)                </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">"x 是 int 型"</span>)                       </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 float64 型"</span>)           </span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">float64</span>:</span></span><br><span class="line">         fmt.Printf("x 是 func(int) 型")                      </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"x 是 bool 或 string 型"</span> )       </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"未知型"</span>)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 </p>
</li>
<li><p>否则：</p>
<p>如果有default子句，则执行该语句。</p>
<p>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>
</li>
</ul>
<h2 id="slice-array切片和数组的创建"><a href="#slice-array切片和数组的创建" class="headerlink" title="slice,array切片和数组的创建"></a>slice,array切片和数组的创建</h2><p>1.数组 ：值传递</p>
<p>​    概念：存储一组相同的数据类型的数据结构。</p>
<p>​    特点：数据结构：内存上是连续空间。</p>
<p>​    存储数据特点：有序，可以重复。</p>
<p>​                数据类型一致。</p>
<p>​                定长：数组一旦创建长度不能更改，但是可以更改存储的数据。</p>
<p>​    语法：</p>
<p>   A：数组的创建</p>
<p>   var variable_name [SIZE] variable_type</p>
<p>​     var a [4] int</p>
<p>​     var b = [4]int{}</p>
<p>​      var c = [4] int {1,2,3,4}</p>
<p>​     var d = [4]int{1,2}//后边补零</p>
<p>​      e := [4]int{index:value}</p>
<p>​      f:=[…] int{}</p>
<p>   B：数组的访问</p>
<p>​      主要通过下标：index，取值范围是：从0开始，到长度减1。</p>
<p>​      index（下标）：,数据在数组中的位置。从0开始，到长度减1。否则越界异常。</p>
<p>​      赋值：数组名[index] = value（数据）</p>
<p>​      取值：数组名[index]</p>
<p>遍历数组：依次获取数组中的数据</p>
<p>​            range 数组名：index，value</p>
<p>​    数组的类型：值类型：传递该数据的时候，传递数据的副本(备份，复制)</p>
<p>​            arr1:=[5] int {1,1,1,1,1}</p>
<p>​            arr2 = arr1//将arr1的数据拷贝一份，值赋值给arr2。</p>
<p>​                        //如果在把arr1的值赋值给arr1之后，更改了arr1的内容，对于arr2没</p>
<p>​                            有影响。因为是值类型，传递的是备份数据。        </p>
<p>​    循环操作数组：</p>
<p>​            for i:=0;i&lt;len(arr);i++{</p>
<p>​                arr[i] </p>
<p>​            }</p>
<p>​            range–&gt;数组：将数组的下标和对应的数值</p>
<p>​            for index,value := range arr{</p>
<p>​                index：下标</p>
<p>​                value：数据</p>
<p>​            }</p>
<p>​    数据类型：数组的类型：[size]type，</p>
<p>​    数组的排序：数组中的数据，按照升序或降序排列。</p>
<p>​    冒泡排序：思路：每次比较相邻的两个数，如果前一个数大于后一个数，交换。排n轮：    </p>
<p>​                长度-1    </p>
<p>a := [5] int {30,31,18,17,15}</p>
<p>for i:=1;i&lt;len(a);i++{</p>
<p> for j:=0;j&lt;len(a)-i;j++{</p>
<p>​     if a[j]&gt;a[j+1]{</p>
<p>​        a[j] ,a[j+1]=a[j+1],a[j]</p>
<p>​      }</p>
<p>   }</p>
<p>   fmt.Println(a)</p>
<p>​    多维数组：二维数组：一维的一维</p>
<p>​            一维数组，直接存储数据本身</p>
<p>​            二维数组，存储的是一维数组</p>
<p>语法：       c := [3][4] int{</p>
<p>​                     {1,2,3,4},</p>
<p>​                     {5,6,7,8},</p>
<p>​                  {9,10,11,12}}</p>
<p>len(b)–&gt;二维数组的长度：存储了几个一维数组</p>
<p>len(b[0])–&gt;第一个一维数组的长度</p>
<p>b[0][0]–&gt;第一个一维数组中，第一个数据</p>
<p>len(),cap()，数组的长度和容量一致的。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9c0a3e77aee595f07194cb7cce079811/xmlnote/0FC740ACE2114E5DA5678F848911BCD6/32BA34A8FF704B5E95B9C9A0C93CB942/418" alt="img"></p>
<p>​                </p>
<p>​    2.切片：slice（引用类型）</p>
<p>​        理解为变长的数组</p>
<p>​        A：切片创建</p>
<p>​            1.创建切片1.直接创建</p>
<p>​                 s1 := [] int{1,2,3,4,5,6,7,8}</p>
<p>​            2.使用make([]T, len,cap) cap如果不给数值，那么和len一致，                                         </p>
<p>​                 s2:=make([]T,len,cap)</p>
<p>​                 s3 := make([]int, 3, 8)</p>
<p>​            3.在数组的基础上创建切片</p>
<p>​                b := [10]int{1,2,3,4,5,6,7,8,9,10}</p>
<p>​                s4 := b[2:6] // 数组名[start:end），start，end指的是下标。不包含end</p>
<p>​                s5 := b[:6] // [0:6]，从头开始，切割刀下标6(不包含6)</p>
<p>​                s6 :=b[6:] // [start:],从start开始，切割刀最后</p>
<p>​        B：切片的类型：</p>
<p>​                []数据类型    </p>
<p>​                切片属于引用类型：</p>
<p>​                s1:=[] int{1,2,3,4}</p>
<p>​                s2:=s1</p>
<p>​            append(slice, ele1,ele2,ele3)//向切片后面直接加数值</p>
<p>​            append(slice1,slice2…)//向切片后面加切片，注意加 …</p>
<p>​        </p>
<h2 id="slice-copy和append方法"><a href="#slice-copy和append方法" class="headerlink" title="slice copy和append方法"></a>slice copy和append方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">len(),存储的实际的数量</span><br><span class="line">cap(),存储的最大的数量，自动扩容：规则：2倍</span><br><span class="line">append(slice, ele1,ele2,ele3)，增加同类型元素</span><br><span class="line">append(slice1,slice2...)，增加切片里元素</span><br><span class="line">cap:0--&gt;1--&gt;2--&gt;4--&gt;8--&gt;16--&gt;32，倍数增加容量</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝 numbers 的内容到 numbers1,如果numbers1的长度小于numbers，那么numbers1内的数值将被全部覆盖 </span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">12</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的</p>
</blockquote>
<p>Append里有个坑，详见例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   a := make([]int, 5, 10)</span><br><span class="line">   b := append(a, 1)//新开辟内存b，b内的值是指针传递，由a传递，a变化，b也会跟着相应变化</span><br><span class="line">   _ = append(a, 2)</span><br><span class="line">   a[0]=9</span><br><span class="line">   a=append(a,3,4,5)</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line">   fmt.Printf(&quot;%p&quot;,&amp;b)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>[9 0 0 0 0 3 4 5]<br>[9 0 0 0 0 3]<br>0xc0420023e0<br>0xc042002400</p>
<h2 id="Map-字典"><a href="#Map-字典" class="headerlink" title="Map 字典"></a>Map 字典</h2><p>Map集合是引用类型：传递时候，传递的是地址。</p>
<pre><code>映射。存储一组无需的键值对的容器。
存储的特点：a.键与值是一一对应的。----&gt;映射
            b.键是唯一的
</code></pre><p>语法：<br>   A：创建：如果一个map仅有声明，就是nil map，不能直接存储数据<br>   var map名 [key类型]value类型<br>   map名:=map[key类型]value类型{}<br>   map名:=make(map[key类型]value类型)<br>   B：向map中添加数据<br>              map[key] = value</p>
<p>   C：获取map的数据：根据key获取value，如果key 不存在<br>         /<em> 使用 key 输出 map 值 </em>/<br>         map1:=make(map[int]string)<br>       for key := range map1 {<br>          fmt.Println(key,map1[key])<br>       }</p>
<pre><code>   /* 查看元素在集合中是否存在 */
   value, ok := map1[key]
   /* 如果 ok 是 true, 则存在，否则不存在 */
   if(ok){
      fmt.Println(value)  
   }else {
      fmt.Println(&quot;value is not present&quot;) 
   }
D：删除键值对
  delete(map,key)
  根据key删除键值对，如果key不存在，删除失败。
</code></pre><p>   E：修改：<br>      根据key修改<br>map的遍历：<br>创建slice，利用append函数，将map中的key值遍历再加入到slice中，排序<br>//1.定义一个slice<br>s1 := make([]int,0,len(map2))<br>//2.遍历map获取key–&gt;s1中<br>for key := range map2{<br>   s1 = append(s1, key)<br>}<br>//3.给s1进行排序<br>sort.Ints(s1)//使用sort包下的方法直接排序，不用自己写冒泡了。<br>//4. 遍历s1，map<br>for _,k:=range s1{ // 先下标，再数值<br>   fmt.Println(k, map2[k])<br>}</p>
<h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><p> 字符串：多个字节的集合。理解为一个字符序列。</p>
<p>​            //长度：字符串中的字节的数量。</p>
<p>​            //序列：有序–&gt;下标，也叫索引，每个字符的位置。从0开始，到长度减1。</p>
<p>​            遍历：可以根据字符的下标，进行访问遍历</p>
<p>​                 for i:=0;i&lt;len(s2);i++{</p>
<pre><code>//fmt.Println(s2[i])

fmt.Printf(&quot;%c\n&quot;,s2[i])
</code></pre><p>​                }</p>
<p>​            字符串—&gt;[]byte</p>
<p>​            []byte(s1)</p>
<p>​            string(arr1)</p>
<p>​        strings函数包使用方法：</p>
<p>​                s1:=”HelloWorld”</p>
<p>​                s2:=”20180403课堂笔记.txt”</p>
<p>​    1.strings.Contains(s,””)：返回值为bool    </p>
<p>​            是否包含指定内容，</p>
<p>​                        fmt.Println(strings.Contains(s1,”O”))</p>
<p>​                        //判断s1中是否包含“0”</p>
<p>​    2.strings.ContainsAny(s,””)：返回值为bool</p>
<p>​            是否包含指定内容中的任意一个，</p>
<p>​                        fmt.Println(strings.ContainsAny(s1,”abcd”))</p>
<p>​                        //判断s1中是否包含”abcd”中的任意一个</p>
<p>​    3.strings.HasPrefix(s,””)：返回值为bool</p>
<p>​            判断s是否有前缀字符串，</p>
<p>​                        if strings.HasPrefix(s2,”201804”) {</p>
<pre><code>fmt.Println(&quot;这个是4月份的笔记。。&quot;)
</code></pre><p>​                        }</p>
<p>​                        //判断s2是不是以”201804”为开头的</p>
<p>​    4.strings.HasSuffix(s,””)：返回值为bool</p>
<p>​            判断s是否有后缀字符串</p>
<p>​                    if strings.HasSuffix(s2,”.txt”){</p>
<pre><code>fmt.Println(&quot;这个是一个文本文档。。&quot;)
</code></pre><p>​                    }</p>
<p>​                    //判断s2是不是以”.txt”为结束的</p>
<p>​    5.strings.Index(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中第一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.Index(s1,”llo”))</p>
<p>​                        //查找s1第一次出现”llo”的下标，不存在则返回-1.</p>
<p>​    6.strings.LastIndex(s,””)：返回值为int</p>
<p>​            子串” “在字符串s中最后一次出现的位置，不存在则返回-1。</p>
<p>​                        fmt.Println(strings.LastIndex(s1,”l”))</p>
<p>​                        //查找s1最后一次出现”l”的下标，不存在则返回-1</p>
<p>​    7.strings.Count(s,””):返回值为int。</p>
<p>​            统计s字符串中出现子串” “的次数。</p>
<p>​                        fmt.Println(strings.Count(s1,”l”))</p>
<p>​                        //统计s1中出现”l”的次数</p>
<p>​    8.strings.Split(s1,””): 返回值为[]string</p>
<p>​                 用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所</p>
<p>​            有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会</p>
<p>​            进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值</p>
<p>​            一个字符串。</p>
<p>​            fmt.Println(strings.Split(“a man a plan a canal panama”, “a “))</p>
<p>​                        [ man  plan  canal panama]</p>
<p>​            //去掉”a man a plan a canal panama”中的”a “，即遇到 “a “以空格代替</p>
<p>​    9.strings.SplitN(s1,””,n): 返回值为[]string</p>
<p>​            指定次数的切割，不超过n次，即切割（n-1）次。如果全切n=-1</p>
<p>​            n == 0: 返回nil</p>
<p>​    10.strings.Join([]strings,””):返回值为string</p>
<p>​            将一系列字符串连接为一个字符串，之间用sep来分隔。</p>
<p>​            input：  s := []string{“foo”, “bar”, “baz”}                fmt.Println(strings.Join(s, “, “))</p>
<p>​            output：  foo, bar, baz</p>
<p>​    11.strings.ToLower(s):转小写，返回值为string</p>
<p>​       strings.ToUpper(s):转大写，返回值为string</p>
<p>​            fmt.Println(strings.ToLower(s1))//转小写</p>
<p>​            fmt.Println(strings.ToUpper(s1))//转大写</p>
<p>​    12.strings.Trim(s,cutset string): 返回值为string</p>
<p>​        返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</p>
<p>​    13.strings.Replace(s,old,new,n)n替换的次数，-1表示全部替换 返回值为string</p>
<p>​    strings.Repeat(s string, count int),=重复的次数  返回值为string</p>
<h2 id="func（）函数"><a href="#func（）函数" class="headerlink" title="func（）函数"></a>func（）函数</h2><p>函数是执行特定任务的代码块，打印函数名输出地址</p>
<p>参数有值传递和引用传递，引用传递将参数类型设为指针，传参&amp;参数</p>
<p>函数参数可以是可变参，如func myfunc(nums …int) </p>
<p>闭包：Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数体为getSequence() 的返回值，以后nextNumber函数自己独立 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回，地址不变 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">  fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="panic-和recover"><a href="#panic-和recover" class="headerlink" title="panic()和recover()"></a>panic()和recover()</h2><p>panic()执行导致程序出现恐慌，系统运行终止。需要借助defer函数使recover()接收错误，并恢复其他函数运行</p>
<p>panic()输出位置不固定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)//主函数终止，无法输出</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机输出1：</p>
<p>0<br>panic: 3<br>1</p>
<p>2<br>goroutine 1 [running]:<br>main.a()<br>    E:/kyxy/day01/ceshi.go:14 +0xed<br>main.main()<br>    E:/kyxy/day01/ceshi.go:8 +0x29</p>
<p>随机输出2：</p>
<p>panic: 3<br>0</p>
<p>1<br>goroutine 1 [running]:<br>2<br>main.a()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:14 +0xed</span><br></pre></td></tr></table></figure>
<p>main.main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:/kyxy/day01/ceshi.go:8 +0x29</span><br></pre></td></tr></table></figure>
<p>使用recover()，主函数输出有序，只是有panic的函数因panic动作，该函数panic后不能继续运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     a()</span><br><span class="line">   fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func a()  &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      defer func() &#123;</span><br><span class="line">         if r := recover(); r != nil &#123;</span><br><span class="line">            fmt.Println(&quot;系统出现panic&quot;, r)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      if i == 3 &#123;</span><br><span class="line">         panic(i)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p>0<br>1<br>2<br>系统出现panic 3<br>hello</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>​    定义指针：</p>
<p>​        var p1 *T</p>
<p>​    &amp;,取地址</p>
<p>​    *,取指针中地址对应的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   /*</span><br><span class="line">   指针：存储另一个变量的内存地址的变量。</span><br><span class="line">   指针的类型，</span><br><span class="line">   指针存储的数据的类型</span><br><span class="line">   指针的地址</span><br><span class="line">   指针存储的变量的地址</span><br><span class="line">    */</span><br><span class="line">    a:=100 //定义了一个变量，变量名：a，变量值：100，变量类型int</span><br><span class="line">    fmt.Printf(&quot;变量的数值：%d，变量的类型：%T\n&quot;,a,a)</span><br><span class="line">    //&amp;,获取变量的内存地址</span><br><span class="line">    fmt.Printf(&quot;变量a的内存地址：%p\n&quot;,&amp;a) //0xc04200e098</span><br><span class="line"></span><br><span class="line">    // 修改变量的值</span><br><span class="line">    a = 200//修改a的数值</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Printf(&quot;%p\n&quot;,&amp;a)</span><br><span class="line"></span><br><span class="line">    //创建一个指针</span><br><span class="line">    var p1 *int</span><br><span class="line">    fmt.Println(p1) //&lt;nil&gt; 空 null</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p1) //*int</span><br><span class="line">    fmt.Printf(&quot;p1自己的地址：%p\n&quot;,&amp;p1)</span><br><span class="line">    p1 = &amp;a //取a的地址，赋值给p1</span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">    fmt.Println(&quot;获取数值：&quot;,*p1)</span><br><span class="line"></span><br><span class="line">    // 指针的的指针</span><br><span class="line">    var p2 **int</span><br><span class="line">    fmt.Println(p2) //nil</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;,p2) //**int</span><br><span class="line">    p2 = &amp;p1 // int--&gt;*int</span><br><span class="line">    fmt.Printf(&quot;p2中存储的数据，就是p1的地址：%p\n&quot;,p2)//p2的值，就是p1的地址</span><br><span class="line">    fmt.Printf(&quot;p2自己的地址：%p\n&quot;,&amp;p2)//p2的地址：</span><br><span class="line"></span><br><span class="line">    fmt.Println(*p1) //*,获取p1指针中存储的内存地址对应的数据。 200</span><br><span class="line">    fmt.Println(*p2) // *p2取值的a的地址</span><br><span class="line">    fmt.Println(**p2)</span><br></pre></td></tr></table></figure>
<p>指针更改数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   a := 100</span><br><span class="line">   p1 := &amp;a</span><br><span class="line">   fmt.Println(a, *p1)//100 100</span><br><span class="line">   *p1++// 操作指针更改变量的数值</span><br><span class="line">   fmt.Println(a, *p1)//101 101</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针及地址打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var a *int</span><br><span class="line">   p:=&amp;a</span><br><span class="line">fmt.Println(*p)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <nil><br>​            0xc042004028</nil></p>
<p>空指针：只声明一个指针不给赋值叫空指针，但是可以给空指针赋值地址，将不再是空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">   var p *int</span><br><span class="line">   a:=10</span><br><span class="line">   p=&amp;a</span><br><span class="line">   fmt.Println(p)</span><br><span class="line">   fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：0xc04204a080<br>​            10</p>
<h2 id="new-和make-区别"><a href="#new-和make-区别" class="headerlink" title="new()和make()区别"></a>new()和make()区别</h2><p><strong>new()</strong><br>这是一个用来分配内存的内置函数，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配的 t 类型的零值的指针。</p>
<p>在golang的代码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(t Type) *Type</span><br></pre></td></tr></table></figure>
<p>直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针,new()返回值是指针。两者是不一样的</p>
<p>两者对比代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>new()与make()区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">new 主要用于结构体的初始化</span><br><span class="line"></span><br><span class="line">make用于数组array，切片slice，协程chnnel的初始化</span><br><span class="line">例如：  users:=make([10]int);</span><br><span class="line">             msg:=make(chan int);</span><br><span class="line"></span><br><span class="line">     new会分配结构空间，并初始化为清空为零，不进一步初始化</span><br><span class="line">     new之后需要一个指针来指向这个结构</span><br><span class="line">     make会分配结构空间及其附属空间，并完成其间的指针初始化</span><br><span class="line">     make返回这个结构空间，不另外分配一个指针</span><br><span class="line">例子new：</span><br><span class="line">     var p *[]int = new([]int)</span><br><span class="line">     或</span><br><span class="line">     p := new([]int)</span><br><span class="line">     以上分配了一个slice结构，但是结构中的应该指向底层数组的ptr指针为空，故实际不能往这个slice里面存取数据</span><br><span class="line">     同时分配了一个指针p，也即(在32位系统中)占4个字节并存放slice结构的地址</span><br><span class="line">例子make：</span><br><span class="line">     var v []int = make([]int, 0)</span><br><span class="line">     v := make([]int, 0)</span><br><span class="line">     以上分配了一个slice结构，且结构中的应该指向底层数组的ptr指针已经指向了某个底层数组，这个底层数组应该已经分配了，故这个slice已经可以使用了</span><br><span class="line">     注意v就是这个slice结构，而不是一个指向slice的指针</span><br><span class="line">     上述仅是示例，一般使用时都会明确长度和容量：v := make([]int, 10, 50)</span><br><span class="line">结论：</span><br><span class="line">     由上可见，用new来分配slice的意义不大，因为没有恰当的初始化，无法直接使用</span><br><span class="line">     有附带空间的结构，使用make来初始化，可以完成内部指针初始化，其后可以立即使用</span><br></pre></td></tr></table></figure>
<h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct{}"></a>结构体struct{}</h2><p>面向对象：不是一门语言，也不是一门技术，而是一种编程思路。</p>
<p>面向对象：<br>    A：考虑问题域中涉及到的对象<br>    B：定义这些对象—&gt;类<br>    C：思考类和类的关系<br>类，对象：面向对象中的量大核心概念<br>类：同一类事物的抽象描述。<br>    静态属性：字段<br>    动态属性：方法<br>对象：类中一个具体的实例。<br>    对象是存在，<br>类和对象的关系？<br>    类是对象的抽象描述，对象是类的一个具体的实例。<br>    将一类对象共同特征，进行抽取—-&gt;定义类<br>    将类进行实例化—&gt;创建对象<br>type Person struct{<br>    name, age, sex<br>}</p>
<p>p1 := Person{“王二狗”,30,”男”} // 将类进行实例化得到对象。<br>p2 := Preson{“李小花”,18,”女”}<br>面向对象的三大特征：<br>1.封装性：<br>    “打包”<br>    函数，方法，结构体。。。<br>2.继承性：<br>    描述一个类和另一个类的关系。<br>    子类继承父类：<br>        子类可以直接访问父类的属性和方法。<br>        子类可以新增自己的属性和方法<br>        子类可以重写父类已有的方法。<br>    靠结构体的嵌套：<br>        匿名字段：提升字段</p>
<pre><code>3.多态性：接口
</code></pre><p>二.结构体<br>1.定义一个结构体<br>type 结构体名 struct{<br>   字段名 类型<br>}<br>type person1 struct {<br>   name string //姓名<br>   age int // 年龄<br>   sex string // 性别<br>}<br>根据类实例化对象：根据结构体创建该结构体类型的变量</p>
<p>2、创建对象：<br>    对象名 := 结构体名{val1,val2,val3…} //保证顺序<br>        p2 := person1{“李小花”, 18,”女”} //注意赋值顺序<br>    对象名 := 结构体名{字段名:val1,字段名:val2,…}<br>        p3 := person1{age:30,sex:”男”,name:”三胖”}<br>    对象名 := 结构体名{}<br>对象名.字段名 ，进行赋值和取值<br>    var p1 person1<br>    p1.name = “王二狗”<br>p1.age = 30<br>p1.sex = “男”<br>对象名 := new(Type) //指针<br>    p5 := new(person1)<br>fmt.Printf(“%T\n”,p5) //<em>main.person1<br>(</em>p5).name=”隔壁老王”<br>p5.age = 30 // 简写<br>p5.sex = “男”<br>fmt.Println(p5) //&amp;{隔壁老王 30 男}<br>结构体为值类型<br>    结构体：<br>   值类型：<br>      p1 := person{…..}<br>   浅拷贝：<br>      指针：<br>         p2:=new(person)<br>         p3:= &amp;p1<br>3.匿名结构体<br>    匿名结构体和匿名字段<br>           匿名结构体：没有名字的结构体<br>                   匿名字段：没有名字的字段，但是有类型。相当于该类型就是字段名<br>                注意点：一个结构体中，匿名字段的类型是唯一的。<br>                创建结构体对象：<br>           对象名:=结构体名{field:value,field:value…}<br>            结构体的嵌套：<br>           一个结构体作为另一个结构体的字段类型<br>三.结构体的嵌套<br>    继承：两个类的继承关系。子类可以使用父类的功能<br>对于go语言，没有真正的继承。靠结构体的嵌套模拟继承功能的。<br>结构体的嵌套：<br>   聚合关系：一个类作为另一个类的属性。has - a<br>      type A struct{}<br>      type B struct{<br>         a A<br>      }<br>   继承关系：一个子类继承一个父类。is - a<br>      type C struct{}<br>      type D struct{<br>         C<br>      }<br>继承：<br>    子类，父类<br>    子类 继承了父类<br>        1.子类可以直接使用父类的属性和方法。<br>        2.子类可以新增自己的属性和方法<br>        3.子类可以重写父类已有的方法</p>
<pre><code>作用和意义：
    1.可以避免重复的代码。
    2.扩展类的功能。(从父类角度)
</code></pre><h2 id="方法methed"><a href="#方法methed" class="headerlink" title="方法methed"></a>方法methed</h2><h3 id="1-1-什么是方法"><a href="#1-1-什么是方法" class="headerlink" title="1.1 什么是方法"></a>1.1 什么是方法</h3><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集</p>
<p>方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。</p>
<h3 id="1-2-方法的语法"><a href="#1-2-方法的语法" class="headerlink" title="1.2 方法的语法"></a>1.2 方法的语法</h3><p>定义方法的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span> <span class="title">methodName</span><span class="params">(parameter list)</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method has Employee as the receiver type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">displaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">//Calling displaySalary() method of Employee type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以定义相同的方法名</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Area of r1 is: "</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of r2 is: "</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c1 is: "</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">"Area of c2 is: "</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Area of r1 is:  24</span><br><span class="line">Area of r2 is:  36</span><br><span class="line">Area of c1 is:  314.1592653589793</span><br><span class="line">Area of c2 is:  1963.4954084936207</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过.访问，就像struct里面访问字段一样 </li>
</ul>
<h3 id="1-3-方法和函数"><a href="#1-3-方法和函数" class="headerlink" title="1.3 方法和函数"></a>1.3 方法和函数</h3><p>既然我们已经有了函数，为什么还要使用方法？</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="keyword">string</span></span><br><span class="line">    salary   <span class="keyword">int</span></span><br><span class="line">    currency <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method converted to function with Employee as parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"Salary of %s is %s%d"</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">"Sam Adolf"</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">"$"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。</p>
</blockquote>
<p>为什么我们可以用函数来写相同的程序呢?有以下几个原因</p>
<ol>
<li>Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。</li>
<li>相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。</li>
</ol>
<h3 id="1-4-变量作用域"><a href="#1-4-变量作用域" class="headerlink" title="1.4 变量作用域"></a>1.4 变量作用域</h3><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p><strong>局部变量</strong></p>
<p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p><strong>全局变量</strong></p>
<p>在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"结果： a = %d, b = %d and g = %d\n"</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果： a = <span class="number">10</span>, b = <span class="number">20</span> and g = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>形式参数</strong></p>
<p>形式参数会作为函数的局部变量来使用</p>
<p><strong>指针作为接收者</strong></p>
<p>若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">SetColor</span><span class="params">(c Color)</span></span> &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>例</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span> <span class="title">setVal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.height = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Rectangle&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := p</span><br><span class="line">	p.setVal()</span><br><span class="line">	fmt.Println(p.height, s.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果没有那个*，则值就是<code>2 2</code></p>
<h3 id="1-5-method继承"><a href="#1-5-method继承" class="headerlink" title="1.5 method继承"></a>1.5 method继承</h3><p>method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam you can call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<h3 id="1-6-method重写"><a href="#1-6-method重写" class="headerlink" title="1.6 method重写"></a>1.6 method重写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>结果</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam, I work at Golang Inc. Call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>
<ul>
<li>方法是可以继承和重写的</li>
<li>存在继承关系时，按照就近原则，进行调用</li>
</ul>
<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><h3 id="一-error"><a href="#一-error" class="headerlink" title="一.error"></a>一.error</h3><pre><code>异常：不正常，程序中存在不正常的事件，导致程序无法正常的执行。
error,错误，来表示程序中的不正常。
    函数() 返回值：error
error 本质上是一个接口，所有能实现 函数名为Error（）返回值为string 方法的结构体都是error的实现类。
    type error interface {
       Error() string
    }
go语言中提供两个函数来实现 返回值string
  errors.New(string)--&gt;error
  fmt.Errorf(format)--&gt;error
error：nil，表示没有错误    
error：Go中表示不正常的错误的类型。

1.2自定义error的实现类
    1.定义一个结构体，实现error接口。即该结构体有个如下的方法
        func (s struct)Error() string{
        //该函数中的返回值string 可以用 fmt.Sprintf()函数实现。改函数即将打印的内            
        容转为string类型
        }
    2：使用--&gt;
                创建error对象，创建自定义实现类的对象即可。
</code></pre><h3 id="二-strconv：字符串和基本类型之间的转换"><a href="#二-strconv：字符串和基本类型之间的转换" class="headerlink" title="二.strconv：字符串和基本类型之间的转换"></a>二.strconv：字符串和基本类型之间的转换</h3><pre><code>string与其他数据类型的转换
</code></pre><p>string–&gt;int,float64,bool….<br>   ParseXXX()<br>      ParseInt(),ParseBool(),ParseFloat()</p>
<p>int,float,bool—&gt;string<br>      FormatXXX()<br>      FormatBool(),FormatInt(),FormatFloat()</p>
<p>Atoi(string)–&gt;int,10进制<br>Itoa(int)–&gt;string,10进制整数–&gt;字符串<br>​    </p>
<h3 id="三-math包"><a href="#三-math包" class="headerlink" title="三.math包"></a>三.math包</h3><p>fmt.Println(math.Abs(float64(i))) //绝对值<br>fmt.Println(math.Ceil(5.0))       //向上取整<br>fmt.Println(math.Floor(5.8))      //向下取整<br>fmt.Println(math.Mod(11, 3))      //取余数，同11%3<br>fmt.Println(math.Modf(5.26))      //取整数，取小数<br>fmt.Println(math.Pow(3, 2))       //x的y次方<br>fmt.Println(math.Pow10(4))        // 10的n次方<br>fmt.Println(math.Sqrt(8))         //开平方<br>fmt.Println(math.Cbrt(8))         //开立方</p>
<h3 id="四-time包"><a href="#四-time包" class="headerlink" title="四.time包"></a>四.time包</h3><pre><code>1.获取时间对象
t1 := time.Now() // 当前的时间
2.创建指定的时间
</code></pre><p>t2 := time.Date(1998,4,12,16,34,0,0,time.Local)<br>fmt.Println(t2)<br>//获取日期<br> year,month,day:=t1.Date()<br> fmt.Println(“年，月，日：”,year,month,day)<br> //获取时间<br> hour,minute,second := t1.Clock()<br> fmt.Println(“时，分，秒：”, hour,minute,second)<br>//获取年，月，日，时，分，秒，星期，纳秒，。。<br>fmt.Println(“年：”, t1.Year()) //年<br>fmt.Println(“月：”,t1.Month())//月<br>fmt.Println(“日：”,t1.Day())//日<br>fmt.Println(“时：”,t1.Hour())//时<br>fmt.Println(“分：”,t1.Minute())//分<br>fmt.Println(“秒：”,t1.Second())//秒<br>fmt.Println(“纳秒：”,t1.Nanosecond())//纳秒<br>fmt.Println(“星期：”,t1.Weekday())//星期<br>fmt.Println(t1.ISOWeek()) //返回年份，第几周<br>fmt.Println(t1.YearDay())<br>//timestamp,时间戳：<br>日期，距离1970年1月1日，0点0时，0分0秒，时间的差值<br>    timeStamp1:=t4.Unix() //秒 差值 3600<br>            timeStamp2:=t4.UnixNano()//纳秒</p>
<pre><code>Duration,时间间隔
t1 := time.Now()
        t2 := t1.Add(time.Nanosecond)//在当前时间上，累加1纳秒，nanosecond即为1
        t3 := t1.Add(time.Minute)// 当前时间上，累加1分钟
        t4:=t1.Add(time.Hour * 24)//当前时间，类加1天
        t5:=t1.AddDate(0,0,3)//累加：年，月，日
</code></pre><p>//两个time之间的间隔<br>    d1:= t1.Sub(t5) //t1-t2<br>//睡眠<br>//time.Sleep(time.Nanosecond)//睡眠1纳秒<br>//time.Sleep(5 * time.Second) //当前正在执行的程序进入睡眠。。<br>//fmt.Println(“over….”)</p>
<p>//睡眠，随机数：[1-10]s<br>// [m,n], rand.Intn(n-m+1)+m<br>rand.Seed(time.Now().UnixNano())<br>num := rand.Intn(10) + 1 //<br>fmt.Println(num)<br>time.Sleep(time.Duration(num) * time.Second)<br>fmt.Println(“睡眠结束。。。”)</p>
<h2 id="文件读写-read-write"><a href="#文件读写-read-write" class="headerlink" title="文件读写 read()  write()"></a>文件读写 read()  write()</h2><p>一.文件，路径</p>
<pre><code>文件，目录
目录：directory
    文件存储的路径位置。
文件：file
    用于存储数据，靠文件的类型存储不同类型的数据。
数据存储：
    程序执行过程中产生的数据：存储在内存中。---&gt;瞬时性。
    文件，硬盘上。持久化存储数据。
程序的执行：
    CPU，内存
文件路径：
    绝对路径：
        从跟盘符开始的路径。
    相对路径：
        参照物。go里面以当前的项目的路径，为相对路径的参照物。
</code></pre><p>二.os包：文件操作<br>文件的信息可以读取进一个[]byte切片。Read和Write方法从切片参数获取其内的字节数。<br>    1.os.Stat<br>    os.Stat(“pathname”)<br>    返回值有两个<br>    fi ：<br>         type FileInfo interface {<br>            Name() string       // 文件的名字（不含扩展名）<br>            Size() int64        // 普通文件返回值表示其大小；其他文件的返回值<br>                                含义各系统不同<br>           Mode() FileMode     // 文件的模式位<br>            ModTime() time.Time // 文件的修改时间<br>            IsDir() bool        // 等价于Mode().IsDir()<br>            Sys() interface{}   // 底层数据来源（可以返回nil）<br>      }<br>    err：该文件路径不正确返回的值<br>2.os.mkdir(“pathname”)–&gt;创建文件，仅一层<br>  os.mkdirall(“pathname”)–&gt;创建文件，可以多层<br>      os.create(“pathname”) <em>file,err–&gt;创建空文件<br>      os.open()</em>file,err–&gt;打开文件<br>  os.remove(),删除文件或文件夹，慎用！！！！<br>      os.removeall(),删除所有，慎用！！！！<br>3.关闭文件<br>defer file.Close()//断开程序和文件之间的链接，释放资源。<br>// 读操作，写数据。。。<br>4.os.Open(“文件名”)–&gt;file指针对象<br>Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是<em>PathError。<br>    表示程序中打开文件，和文件建立连接，可以操作文件了。<br>    就是操作file对象，就是操作文件。。<br>os.OpenFile<br>    OpenFile(filename，flag，perm)–&gt;</em>File,err  <strong>*</strong><br>            filename：文件名字<br>            flag，获取file的打开模式：<br>                O_RDONLY<br>                O_WRONLY<br>                O_RDWR<br>                O_CREATE</p>
<pre><code>perm，如果文件不存在，需要指定创建的文件的权限
    0777,0666
    -rw-
</code></pre><p>5.文件读写<em>**<br>    Read([]byte)–&gt;count,err，读取数据<br>默认从头开始读取<br>   光标在最后，再次读取，返回error为io.EOF<br>    func (f </em>File) Read(b []byte) (n int, err error)<br>    Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。</p>
<pre><code>ReadAt([] byte, off)--&gt;coutn,err，从指定off位置读取
    unc (f *File) ReadAt(b []byte, off int64) (n int, err error)
ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。

Write([]byte)--&gt;count,err，写出字节数组
    func (f *File) Write(b []byte) (n int, err error)
Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteAt([]byte,off)，在指定位置写出数据。
    func (f *File) WriteAt(b []byte, off int64) (n int, err error)
    WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

WriteString(string)，直接写出字符串
    func (f *File) WriteString(s string) (ret int, err error)
    WriteString类似Write，但接受一个字符串参数。

Seek(offset, whence)，设置光标的未知
    offset,偏移量
    whence，从哪开始：0从头，1当前，2末尾

    filepath包
        Abs()
            获取绝对路径：程序中以当前工程为参照。
        IsAbs()
            判断是否是绝对路径

        绝对路径：Absolute
            从跟盘符开始描述

        相对路径：Relative
            相对于参照物
</code></pre><p>三.io/ioutil包<br>    io包<br>        Copy(Write，Reader)–&gt;total,err<br>            拷贝文件<br>        func copyFile2(destName, srcName string)(int64, error){<br>   srcFile ,err:= os.Open(srcName)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer srcFile.Close()<br>   destFile,err:=os.OpenFile(destName,os.O_WRONLY|os.O_CREATE,0777)<br>   if err!=nil{<br>      return 0, err<br>   }<br>   defer destFile.Close()<br>   return io.Copy(destFile,srcFile)<br>}</p>
<p>ioUtil包<br>    ReadFile(filename)–&gt;data []byte   <strong>*</strong><br>        读取指定文件中的所有内容<br>    WriteFile(filename, data [] byte,FileMode) <strong>*</strong><br>        向指定文件中写出数据，</p>
<pre><code>ReadAll()

ReadDir(dirname)--&gt;[]FileInfo
    获取指定目录下的子内容，只有一层
</code></pre><p>​<br>​<br>​<br>​        </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-第18章-反射"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/04/21/第18章-反射/">反射reflect</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/04/21/第18章-反射/" class="article-date">
	  <time datetime="2018-04-21T12:53:11.000Z" itemprop="datePublished">April 21, 2018</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>#反射reflect</p>
<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>Java的反射机制是其标志性的特征之一，正是这种语言本身支持的强大的机制使得很多流行的框架有了用武之地。C++中虽然也能实现，但是语言本身并没有提供标准的支持。<br>而作为一门现代的语言，go语言也引入了反射机制，在这篇文章中我们将会了解一下go语言中的反射机制是如何使用的。</p>
<p>反射机制<br>反射机制是程序能够检查其自身结构，属于元编程的范畴，强大的同时也往往是困扰的源头。虽然各种语言的反射模型有所不同，但是通过简单的比较也能有所收获。在了解Go的反射机制之前先来看看Java的反射机制吧。</p>
<p>Java的反射机制<br>我们所熟知的Java的反射机制是什么？对于类和对象的使用，普通的方式是知道类和对象的属性和方法之后进行调用或者访问。<br>而反射机制，简单来说，是在运行状态中，Java对于任何的类，都能够确认到这个类的所有方法和属性；对于任何一个对象，都能调用它的任意方法和属性。这种动态获取或者调用的方式就是Java的反射机制。</p>
<p>能做什么<br>在Java中，通过反射机制在运行时能够做到如下：</p>
<p>确认对象的类<br>确认类的所有成员变量和方法<br>动态调用任意一个对象的方法<br>…</p>
<h2 id="二、相关基础"><a href="#二、相关基础" class="headerlink" title="二、相关基础"></a>二、相关基础</h2><p>在进行更加详细的了解之前，我们需要重新温习一下Go语言相关的一些特性，所谓温故知新，从这些特性中了解其反射机制是如何使用的。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>go语言是静态类型语言。</td>
<td>编译时类型已经确定，比如对已基本数据类型的再定义后的类型，反射时候需要确认返回的是何种类型。</td>
</tr>
<tr>
<td>空接口interface{}</td>
<td>go的反射机制是要通过接口来进行的，而类似于Java的Object的空接口可以和任何类型进行交互，因此对基本数据类型等的反射也直接利用了这一特点</td>
</tr>
</tbody>
</table>
<h2 id="三、反射的使用"><a href="#三、反射的使用" class="headerlink" title="三、反射的使用"></a>三、反射的使用</h2><p>所谓反射就是动态运行时的状态。我们一般用到的包是reflect包</p>
<p>使用reflect一般分成三步：</p>
<p>首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i) <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i) <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>
<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br></pre></td></tr></table></figure>
<p>如果是struct的话，可以使用Elem()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag <span class="comment">//获取定义在struct里面的Tag属性</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String() <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()<span class="comment">//必须的步骤</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//1.“接口类型变量”=&gt;“反射类型对象”</span></span><br><span class="line">	<span class="keyword">var</span> circle <span class="keyword">float64</span> = <span class="number">6.28</span></span><br><span class="line">	<span class="keyword">var</span> icir <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	icir = circle</span><br><span class="line">	fmt.Println(<span class="string">"Reflect : circle.Value = "</span>, reflect.ValueOf(icir)) <span class="comment">//Reflect : circle.Value =  6.28</span></span><br><span class="line">	fmt.Println(<span class="string">"Reflect : circle.Type  = "</span>, reflect.TypeOf(icir)) <span class="comment">//Reflect : circle.Type =  float64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. “反射类型对象”=&gt;“接口类型变量</span></span><br><span class="line">	v1 := reflect.ValueOf(icir)</span><br><span class="line">	fmt.Println(v1) <span class="comment">//6.28</span></span><br><span class="line">	fmt.Println(v1.Interface()) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	y := v1.Interface().(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(y) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//v1.SetFloat(4.13) //panic: reflect: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">	<span class="comment">//fmt.Println(v1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.修改</span></span><br><span class="line">	fmt.Println(v1.CanSet())<span class="comment">//是否可以进行修改</span></span><br><span class="line">	v2 := reflect.ValueOf(&amp;circle) <span class="comment">// 传递指针才能修改</span></span><br><span class="line">	v4:=v2.Elem()<span class="comment">// 传递指针才能修改,获取Elem()才能修改</span></span><br><span class="line">	fmt.Println(v4.CanSet()) <span class="comment">//true</span></span><br><span class="line">	v4.SetFloat(<span class="number">3.14</span>)</span><br><span class="line">	fmt.Println(circle) <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、结构体"><a href="#四、结构体" class="headerlink" title="四、结构体"></a>四、结构体</h2><h3 id="4-1可以通过反射，获取结构体对象的属性和方法"><a href="#4-1可以通过反射，获取结构体对象的属性和方法" class="headerlink" title="4.1可以通过反射，获取结构体对象的属性和方法"></a>4.1可以通过反射，获取结构体对象的属性和方法</h3><h3 id="4-2可以通过反射，调用结构体方法"><a href="#4-2可以通过反射，调用结构体方法" class="headerlink" title="4.2可以通过反射，调用结构体方法"></a>4.2可以通过反射，调用结构体方法</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.提供一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.提供一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Say</span><span class="params">(msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello.."</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">PrintInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"姓名："</span>,p.Name,<span class="string">"年龄："</span>,p.Age,<span class="string">"性别："</span>,p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	p1:=Person&#123;<span class="string">"王二狗"</span>,<span class="number">30</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">	<span class="comment">//反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</span></span><br><span class="line">	<span class="comment">//1.获取对象的类型</span></span><br><span class="line">	t1:=reflect.TypeOf(p1)</span><br><span class="line">	fmt.Println(t1) <span class="comment">//main.Person</span></span><br><span class="line">	fmt.Println(<span class="string">"p1的类型是："</span>,t1.Name())<span class="comment">//调用t.Name方法来获取这个类型的名称</span></span><br><span class="line">	k1:=t1.Kind() <span class="comment">//struct</span></span><br><span class="line">	fmt.Println(k1)</span><br><span class="line">	<span class="comment">//2.获取值，如果是结构体类型，获取的是字段的值</span></span><br><span class="line">	v1:=reflect.ValueOf(p1) <span class="comment">//&#123;王二狗 30 男&#125;</span></span><br><span class="line">	fmt.Println(v1)</span><br><span class="line">	<span class="keyword">if</span> t1.Kind() == reflect.Struct&#123;</span><br><span class="line">		<span class="comment">//是结构体类型，获取里面的字段名字</span></span><br><span class="line">		fmt.Println(t1.NumField()); <span class="comment">//3</span></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumField();i++&#123;</span><br><span class="line">			field := t1.Field(i)</span><br><span class="line">			<span class="comment">//fmt.Println(field) //&#123;Name  string  0 [0] false&#125;,&#123;Age  int  16 [1] false&#125;,&#123;Sex  string  24 [2] false&#125;</span></span><br><span class="line">			val:=v1.Field(i).Interface()<span class="comment">//通过interface方法来取出这个字段所对应的值</span></span><br><span class="line">			fmt.Printf(<span class="string">"字段名字：%s,字段类型：%s,字段数值：%v\n"</span>,field.Name,field.Type,val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.操作方法</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumMethod();i++&#123;</span><br><span class="line">		m:=t1.Method(i)</span><br><span class="line">		fmt.Println(m.Name,m.Type) <span class="comment">//Hello func(main.Person)</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		&#123;Hello  func(main.Person) &lt;func(main.Person) Value&gt; 0&#125;</span></span><br><span class="line"><span class="comment">		&#123;PrintInfo  func(main.Person) &lt;func(main.Person) Value&gt; 1&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m1 := v1.MethodByName(<span class="string">"Say"</span>)</span><br><span class="line">	args:=[]reflect.Value&#123;reflect.ValueOf(<span class="string">"干啥呢？"</span>)&#125;</span><br><span class="line">	m1.Call(args)</span><br><span class="line"></span><br><span class="line">	m2:=v1.MethodByName(<span class="string">"PrintInfo"</span>)</span><br><span class="line">	m2.Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体中包含匿名结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal</span><br><span class="line">	Color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取匿名字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	c1:= Cat&#123;Animal&#123;<span class="string">"猫咪"</span>,<span class="number">1</span>&#125;,<span class="string">"白色"</span>&#125;</span><br><span class="line">	t1:=reflect.TypeOf(c1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t1.NumField();i++&#123;</span><br><span class="line">		fmt.Println(t1.Field(i))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		&#123;Animal  main.Animal  0 [0] true&#125;</span></span><br><span class="line"><span class="comment">		&#123;Color  string  24 [1] false&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// FiledByIndex()的参数是一个切片，第一个数是Animal字段，第二个参数是Animal的第一个字段</span></span><br><span class="line">	f1:=t1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">	f2:=t1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;)</span><br><span class="line">	fmt.Println(f1)<span class="comment">//&#123;Name  string  0 [0] false&#125;</span></span><br><span class="line">	fmt.Println(f2) <span class="comment">//&#123;Age  int  16 [1] false&#125;</span></span><br><span class="line"></span><br><span class="line">	v1:=reflect.ValueOf(c1)</span><br><span class="line">	fmt.Println(v1.Field(<span class="number">0</span>)) <span class="comment">//&#123;猫咪 1&#125;</span></span><br><span class="line">	fmt.Println(v1.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)) <span class="comment">//猫咪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-可以通过反射，修改结构体的数据"><a href="#4-3-可以通过反射，修改结构体的数据" class="headerlink" title="4.3.可以通过反射，修改结构体的数据"></a>4.3.可以通过反射，修改结构体的数据</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	修改内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s1:= Student&#123;<span class="string">"王二狗"</span>,<span class="number">18</span>,<span class="string">"清华大学"</span>&#125;</span><br><span class="line">	v1 := reflect.ValueOf(&amp;s1)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> v1.Kind() ==reflect.Ptr &amp;&amp; v1.Elem().CanSet()&#123;</span><br><span class="line">		v1 = v1.Elem()</span><br><span class="line">		fmt.Println(<span class="string">"可以修改。。"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f1:=v1.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">	fmt.Println(f1.CanSet())</span><br><span class="line">	f1.SetString(<span class="string">"王三狗"</span>)</span><br><span class="line">	f2:=v1.FieldByName(<span class="string">"Age"</span>)</span><br><span class="line">	fmt.Println(f2.CanSet())</span><br><span class="line">	f2.SetInt(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-第5章-Map"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/04/03/第5章-Map/">集合(Map)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/04/03/第5章-Map/" class="article-date">
	  <time datetime="2018-04-03T04:05:03.000Z" itemprop="datePublished">April 3, 2018</time>
	</a>

       
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、集合-Map"><a href="#一、集合-Map" class="headerlink" title="一、集合(Map)"></a>一、集合(Map)</h1><h2 id="1-1-什么是Map"><a href="#1-1-什么是Map" class="headerlink" title="1.1 什么是Map"></a>1.1 什么是Map</h2><p>map是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。</p>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型</p>
<p>使用map过程中需要注意的几点： </p>
<ul>
<li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
<li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
<li>内置的len函数同样适用于map，返回map拥有的key的数量 </li>
<li>map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。</li>
</ul>
<h2 id="1-2-Map的使用"><a href="#1-2-Map的使用" class="headerlink" title="1.2  Map的使用"></a>1.2  Map的使用</h2><h3 id="1-2-1-使用make-创建map"><a href="#1-2-1-使用make-创建map" class="headerlink" title="1.2.1 使用make()创建map"></a>1.2.1 使用make()创建map</h3><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rating := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float32</span> &#123;<span class="string">"C"</span>:<span class="number">5</span>, <span class="string">"Go"</span>:<span class="number">4.5</span>, <span class="string">"Python"</span>:<span class="number">4.5</span>, <span class="string">"C++"</span>:<span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">"France"</span>] = <span class="string">"Paris"</span></span><br><span class="line">   countryCapitalMap[<span class="string">"Italy"</span>] = <span class="string">"Rome"</span></span><br><span class="line">   countryCapitalMap[<span class="string">"Japan"</span>] = <span class="string">"Tokyo"</span></span><br><span class="line">   countryCapitalMap[<span class="string">"India"</span>] = <span class="string">"New Delhi"</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Capital of"</span>,country,<span class="string">"is"</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">"United States"</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">"Capital of United States is"</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Capital of United States is not present"</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-delete-函数"><a href="#1-2-2-delete-函数" class="headerlink" title="1.2.2 delete() 函数"></a>1.2.2 delete() 函数</h3><p>delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span> &#123;<span class="string">"France"</span>:<span class="string">"Paris"</span>,<span class="string">"Italy"</span>:<span class="string">"Rome"</span>,<span class="string">"Japan"</span>:<span class="string">"Tokyo"</span>,<span class="string">"India"</span>:<span class="string">"New Delhi"</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">"原始 map"</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Capital of"</span>,country,<span class="string">"is"</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">"France"</span>);</span><br><span class="line">   fmt.Println(<span class="string">"Entry for France is deleted"</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">"删除元素后 map"</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Capital of"</span>,country,<span class="string">"is"</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始 <span class="keyword">map</span></span><br><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Entry <span class="keyword">for</span> France is deleted</span><br><span class="line">删除元素后 <span class="keyword">map</span></span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-ok-idiom"><a href="#1-2-3-ok-idiom" class="headerlink" title="1.2.3 ok-idiom"></a>1.2.3 ok-idiom</h3><p>我们可以通过key获取map中对应的value值。语法为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>
<p>但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。</p>
<p>所以我们可以使用ok-idiom获取值，可知道key/value是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	m[<span class="string">"a"</span>] = <span class="number">1</span></span><br><span class="line">	x, ok := m[<span class="string">"b"</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">	x, ok = m[<span class="string">"a"</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-map的长度"><a href="#1-2-4-map的长度" class="headerlink" title="1.2.4 map的长度"></a>1.2.4 map的长度</h3><p>使用len函数可以确定map的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="keyword">map</span>)  <span class="comment">// 可以得到map的长度</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-map是引用类型的"><a href="#1-2-5-map是引用类型的" class="headerlink" title="1.2.5 map是引用类型的"></a>1.2.5 map是引用类型的</h3><p>与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    personSalary := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">        <span class="string">"steve"</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">"jamie"</span>: <span class="number">15000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    personSalary[<span class="string">"mike"</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">"Original person salary"</span>, personSalary)</span><br><span class="line">    newPersonSalary := personSalary</span><br><span class="line">    newPersonSalary[<span class="string">"mike"</span>] = <span class="number">18000</span></span><br><span class="line">    fmt.Println(<span class="string">"Person salary changed"</span>, personSalary)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original person salary map[steve:12000 jamie:15000 mike:9000]  </span><br><span class="line">Person salary changed map[steve:12000 jamie:15000 mike:18000]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map不能使用==操作符进行比较。==只能用来检查map是否为空。否则会报错：invalid operation: map1 == map2 (map can only be comparedto nil)</p>
</blockquote>
<p><strong>make、new操作</strong></p>
<p>make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配<br>内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：<br>new返回指针</p>
<p>内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初<br>始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。</p>
<p>make返回初始化后的（非零）值。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/SmarterEric" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="https://baidu.com" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/05/02/Golang细节汇总/">go语言细节及重点汇总</a></h6>
              <span>May 2, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/21/第18章-反射/">反射reflect</a></h6>
              <span>April 21, 2018</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2018/04/03/第5章-Map/">集合(Map)</a></h6>
              <span>April 3, 2018</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2018 Hexo All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
